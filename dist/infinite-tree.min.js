/*! infinite-tree v1.18.0 | (c) 2024 Cheton Wu <cheton@gmail.com> | MIT | https://github.com/cheton/infinite-tree */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["InfiniteTree"] = factory();
	else
		root["InfiniteTree"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/browser.js":
/*!************************!*\
  !*** ./lib/browser.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIEVersion = void 0;\n// https://gist.github.com/padolsey/527683#comment-786682\nvar getIEVersion = exports.getIEVersion = function getIEVersion() {\n  var div = document.createElement('div');\n  var all = div.getElementsByTagName('i') || [];\n  var v = 3;\n  do {\n    ++v;\n    div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->';\n  } while (all[0]);\n  return v > 4 ? v : document.documentMode;\n};\n\n//# sourceURL=webpack://InfiniteTree/./lib/browser.js?");

/***/ }),

/***/ "./lib/clusterize.js":
/*!***************************!*\
  !*** ./lib/clusterize.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar _ensureArray = _interopRequireDefault(__webpack_require__(/*! ./ensure-array */ \"./lib/ensure-array.js\"));\nvar _browser = __webpack_require__(/*! ./browser */ \"./lib/browser.js\");\nvar _dom = __webpack_require__(/*! ./dom */ \"./lib/dom.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ie = (0, _browser.getIEVersion)();\nvar Clusterize = /*#__PURE__*/function (_EventEmitter) {\n  function Clusterize(options) {\n    var _this;\n    _classCallCheck(this, Clusterize);\n    _this = _callSuper(this, Clusterize);\n    _defineProperty(_this, \"options\", {\n      rowsInBlock: 50,\n      blocksInCluster: 4,\n      tag: null,\n      emptyClass: '',\n      emptyText: '',\n      keepParity: true\n    });\n    _defineProperty(_this, \"state\", {\n      lastClusterIndex: -1,\n      itemHeight: 0,\n      blockHeight: 0,\n      clusterHeight: 0\n    });\n    _defineProperty(_this, \"scrollElement\", null);\n    _defineProperty(_this, \"contentElement\", null);\n    _defineProperty(_this, \"rows\", []);\n    _defineProperty(_this, \"cache\", {});\n    _defineProperty(_this, \"scrollEventListener\", function () {\n      var debounce = null;\n      return function () {\n        var isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;\n        if (isMac) {\n          if (_this.contentElement.style.pointerEvents !== 'none') {\n            _this.contentElement.style.pointerEvents = 'none';\n          }\n          if (debounce) {\n            clearTimeout(debounce);\n            debounce = null;\n          }\n          debounce = setTimeout(function () {\n            debounce = null;\n            _this.contentElement.style.pointerEvents = 'auto';\n          }, 50);\n        }\n        var clusterIndex = _this.getCurrentClusterIndex();\n        if (_this.state.lastClusterIndex !== clusterIndex) {\n          _this.changeDOM();\n        }\n        _this.state.lastClusterIndex = clusterIndex;\n      };\n    }());\n    _defineProperty(_this, \"resizeEventListener\", function () {\n      var debounce = null;\n      return function () {\n        if (debounce) {\n          clearTimeout(debounce);\n          debounce = null;\n        }\n        debounce = setTimeout(function () {\n          var prevItemHeight = _this.state.itemHeight;\n          var current = _this.computeHeight();\n          if (current.itemHeight > 0 && prevItemHeight !== current.itemHeight) {\n            _this.state = _objectSpread(_objectSpread({}, _this.state), current);\n            _this.update(_this.rows);\n          }\n        }, 100);\n      };\n    }());\n    if (!(_this instanceof Clusterize)) {\n      return _possibleConstructorReturn(_this, new Clusterize(options));\n    }\n    _this.options = Object.keys(_this.options).reduce(function (acc, key) {\n      if (options[key] !== undefined) {\n        acc[key] = options[key];\n      } else {\n        acc[key] = _this.options[key];\n      }\n      return acc;\n    }, {});\n    _this.scrollElement = options.scrollElement;\n    _this.contentElement = options.contentElement;\n\n    // Keep focus on the scrolling content\n    if (!_this.contentElement.hasAttribute('tabindex')) {\n      _this.contentElement.setAttribute('tabindex', 0);\n    }\n    if (Array.isArray(options.rows)) {\n      _this.rows = options.rows;\n    } else {\n      _this.rows = [];\n      var nodes = _this.contentElement.children;\n      var length = nodes.length;\n      for (var i = 0; i < length; ++i) {\n        var node = nodes[i];\n        _this.rows.push(node.outerHTML || '');\n      }\n    }\n\n    // Remember scroll position\n    var scrollTop = _this.scrollElement.scrollTop;\n    _this.changeDOM();\n\n    // Restore scroll position\n    _this.scrollElement.scrollTop = scrollTop;\n    (0, _dom.addEventListener)(_this.scrollElement, 'scroll', _this.scrollEventListener);\n    (0, _dom.addEventListener)(window, 'resize', _this.resizeEventListener);\n    return _this;\n  }\n  _inherits(Clusterize, _EventEmitter);\n  return _createClass(Clusterize, [{\n    key: \"destroy\",\n    value: function destroy(clean) {\n      (0, _dom.removeEventListener)(this.scrollElement, 'scroll', this.scrollEventListener);\n      (0, _dom.removeEventListener)(window, 'resize', this.resizeEventListener);\n      var rows = clean ? this.generateEmptyRow() : this.rows();\n      this.setContent(rows.join(''));\n    }\n  }, {\n    key: \"update\",\n    value: function update(rows) {\n      this.rows = (0, _ensureArray[\"default\"])(rows);\n\n      // Remember scroll position\n      var scrollTop = this.scrollElement.scrollTop;\n      if (this.rows.length * this.state.itemHeight < scrollTop) {\n        this.scrollElement.scrollTop = 0;\n        this.state.lastClusterIndex = 0;\n      }\n      this.changeDOM();\n\n      // Restore scroll position\n      this.scrollElement.scrollTop = scrollTop;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.rows = [];\n      this.update();\n    }\n  }, {\n    key: \"append\",\n    value: function append(rows) {\n      rows = (0, _ensureArray[\"default\"])(rows);\n      if (!rows.length) {\n        return;\n      }\n      this.rows = this.rows.concat(rows);\n      this.changeDOM();\n    }\n  }, {\n    key: \"prepend\",\n    value: function prepend(rows) {\n      rows = (0, _ensureArray[\"default\"])(rows);\n      if (!rows.length) {\n        return;\n      }\n      this.rows = rows.concat(this.rows);\n      this.changeDOM();\n    }\n  }, {\n    key: \"computeHeight\",\n    value: function computeHeight() {\n      if (!this.rows.length) {\n        return {\n          clusterHeight: 0,\n          blockHeight: this.state.blockHeight,\n          itemHeight: this.state.itemHeight\n        };\n      } else {\n        var nodes = this.contentElement.children;\n        var node = nodes[Math.floor(nodes.length / 2)];\n        var itemHeight = node.getBoundingClientRect().height;\n        if (this.options.tag === 'tr' && (0, _dom.getElementStyle)(this.contentElement, 'borderCollapse') !== 'collapse') {\n          itemHeight += parseInt((0, _dom.getElementStyle)(this.contentElement, 'borderSpacing'), 10) || 0;\n        }\n        if (this.options.tag !== 'tr') {\n          var marginTop = parseInt((0, _dom.getElementStyle)(node, 'marginTop'), 10) || 0;\n          var marginBottom = parseInt((0, _dom.getElementStyle)(node, 'marginBottom'), 10) || 0;\n          itemHeight += Math.max(marginTop, marginBottom);\n        }\n        var blockHeight = itemHeight * this.options.rowsInBlock;\n        var clusterHeight = blockHeight * this.options.blocksInCluster;\n        return {\n          itemHeight: itemHeight,\n          blockHeight: blockHeight,\n          clusterHeight: clusterHeight\n        };\n      }\n    }\n  }, {\n    key: \"getCurrentClusterIndex\",\n    value: function getCurrentClusterIndex() {\n      var _this$state = this.state,\n        blockHeight = _this$state.blockHeight,\n        clusterHeight = _this$state.clusterHeight;\n      if (!blockHeight || !clusterHeight) {\n        return 0;\n      }\n      return Math.floor(this.scrollElement.scrollTop / (clusterHeight - blockHeight)) || 0;\n    }\n  }, {\n    key: \"generateEmptyRow\",\n    value: function generateEmptyRow() {\n      var _this$options = this.options,\n        tag = _this$options.tag,\n        emptyText = _this$options.emptyText,\n        emptyClass = _this$options.emptyClass;\n      if (!tag || !emptyText) {\n        return [];\n      }\n      var emptyRow = document.createElement(tag);\n      emptyRow.className = emptyClass;\n      if (tag === 'tr') {\n        var td = document.createElement('td');\n        td.colSpan = 100;\n        td.appendChild(document.createTextNode(emptyText));\n        emptyRow.appendChild(td);\n      } else {\n        emptyRow.appendChild(document.createTextNode(emptyText));\n      }\n      return [emptyRow.outerHTML];\n    }\n  }, {\n    key: \"renderExtraTag\",\n    value: function renderExtraTag(className, height) {\n      var tag = document.createElement(this.options.tag);\n      var prefix = 'infinite-tree-';\n      tag.className = [prefix + 'extra-row', prefix + className].join(' ');\n      if (height) {\n        tag.style.height = height + 'px';\n      }\n      return tag.outerHTML;\n    }\n  }, {\n    key: \"changeDOM\",\n    value: function changeDOM() {\n      if (!this.state.clusterHeight && this.rows.length > 0) {\n        if (ie && ie <= 9 && !this.options.tag) {\n          this.options.tag = this.rows[0].match(/<([^>\\s/]*)/)[1].toLowerCase();\n        }\n        if (this.contentElement.children.length <= 1) {\n          this.cache.content = this.setContent(this.rows[0] + this.rows[0] + this.rows[0]);\n        }\n        if (!this.options.tag) {\n          this.options.tag = this.contentElement.children[0].tagName.toLowerCase();\n        }\n        this.state = _objectSpread(_objectSpread({}, this.state), this.computeHeight());\n      }\n      var topOffset = 0;\n      var bottomOffset = 0;\n      var rows = [];\n      if (this.rows.length < this.options.rowsInBlock) {\n        rows = this.rows.length > 0 ? this.rows : this.generateEmptyRow();\n      } else {\n        var rowsInCluster = this.options.rowsInBlock * this.options.blocksInCluster;\n        var clusterIndex = this.getCurrentClusterIndex();\n        var visibleStart = Math.max((rowsInCluster - this.options.rowsInBlock) * clusterIndex, 0);\n        var visibleEnd = visibleStart + rowsInCluster;\n        topOffset = Math.max(visibleStart * this.state.itemHeight, 0);\n        bottomOffset = Math.max((this.rows.length - visibleEnd) * this.state.itemHeight, 0);\n\n        // Returns a shallow copy of the rows selected from `visibleStart` to `visibleEnd` (`visibleEnd` not included).\n        rows = this.rows.slice(visibleStart, visibleEnd);\n      }\n      var content = rows.join('');\n      var contentChanged = this.checkChanges('content', content);\n      var topOffsetChanged = this.checkChanges('top', topOffset);\n      var bottomOffsetChanged = this.checkChanges('bottom', bottomOffset);\n      if (contentChanged || topOffsetChanged) {\n        var layout = [];\n        if (topOffset > 0) {\n          if (this.options.keepParity) {\n            layout.push(this.renderExtraTag('keep-parity'));\n          }\n          layout.push(this.renderExtraTag('top-space', topOffset));\n        }\n        layout.push(content);\n        if (bottomOffset > 0) {\n          layout.push(this.renderExtraTag('bottom-space', bottomOffset));\n        }\n        this.emit('clusterWillChange');\n        this.setContent(layout.join(''));\n        this.emit('clusterDidChange');\n      } else if (bottomOffsetChanged) {\n        this.contentElement.lastChild.style.height = bottomOffset + 'px';\n      }\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent(content) {\n      // For IE 9 and older versions\n      if (ie && ie <= 9 && this.options.tag === 'tr') {\n        var div = document.createElement('div');\n        div.innerHTML = \"<table><tbody>\".concat(content, \"</tbody></table>\");\n        var lastChild = this.contentElement.lastChild;\n        while (lastChild) {\n          this.contentElement.removeChild(lastChild);\n          lastChild = this.contentElement.lastChild;\n        }\n        var rowsNodes = this.getChildNodes(div.firstChild.firstChild);\n        while (rowsNodes.length) {\n          this.contentElement.appendChild(rowsNodes.shift());\n        }\n      } else {\n        this.contentElement.innerHTML = content;\n      }\n    }\n  }, {\n    key: \"getChildNodes\",\n    value: function getChildNodes(tag) {\n      var childNodes = tag.children;\n      var nodes = [];\n      var length = childNodes.length;\n      for (var i = 0; i < length; i++) {\n        nodes.push(childNodes[i]);\n      }\n      return nodes;\n    }\n  }, {\n    key: \"checkChanges\",\n    value: function checkChanges(type, value) {\n      var changed = value !== this.cache[type];\n      this.cache[type] = value;\n      return changed;\n    }\n  }]);\n}(_events.EventEmitter);\nvar _default = exports[\"default\"] = Clusterize;\n\n//# sourceURL=webpack://InfiniteTree/./lib/clusterize.js?");

/***/ }),

/***/ "./lib/dom.js":
/*!********************!*\
  !*** ./lib/dom.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopPropagation = exports.removeEventListener = exports.preventDefault = exports.getElementStyle = exports.addEventListener = void 0;\nvar getElementStyle = exports.getElementStyle = function getElementStyle(el, prop) {\n  return window.getComputedStyle ? window.getComputedStyle(el)[prop] : el.currentStyle[prop];\n};\nvar preventDefault = exports.preventDefault = function preventDefault(e) {\n  if (typeof e.preventDefault !== 'undefined') {\n    e.preventDefault();\n  } else {\n    e.returnValue = false;\n  }\n};\nvar stopPropagation = exports.stopPropagation = function stopPropagation(e) {\n  if (typeof e.stopPropagation !== 'undefined') {\n    e.stopPropagation();\n  } else {\n    e.cancelBubble = true;\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Compatibility\nvar addEventListener = exports.addEventListener = function addEventListener(target, type, listener) {\n  if (target.addEventListener) {\n    // Standard\n    target.addEventListener(type, listener, false);\n  } else if (target.attachEvent) {\n    // IE8\n    // In Internet Explorer versions before IE 9, you have to use attachEvent rather than the standard addEventListener.\n    target.attachEvent('on' + type, listener);\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\nvar removeEventListener = exports.removeEventListener = function removeEventListener(target, type, listener) {\n  if (target.removeEventListener) {\n    // Standard\n    target.removeEventListener(type, listener, false);\n  } else if (target.detachEvent) {\n    // IE8\n    // In Internet Explorer versions before IE 9, you have to use detachEvent rather than the standard removeEventListener.\n    target.detachEvent('on' + type, listener);\n  }\n};\n\n//# sourceURL=webpack://InfiniteTree/./lib/dom.js?");

/***/ }),

/***/ "./lib/ensure-array.js":
/*!*****************************!*\
  !*** ./lib/ensure-array.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar ensureArray = function ensureArray() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length === 0 || args[0] === undefined || args[0] === null) {\n    return [];\n  }\n  if (args.length === 1) {\n    return [].concat(args[0]);\n  }\n  return [].concat(args);\n};\nvar _default = exports[\"default\"] = ensureArray;\n\n//# sourceURL=webpack://InfiniteTree/./lib/ensure-array.js?");

/***/ }),

/***/ "./lib/extend.js":
/*!***********************!*\
  !*** ./lib/extend.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint no-restricted-syntax: 0 */\nvar extend = function extend(target) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n  var output = Object(target);\n  for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); index++) {\n    var source = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];\n    if (source !== undefined && source !== null) {\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          output[key] = source[key];\n        }\n      }\n    }\n  }\n  return output;\n};\nmodule.exports = extend;\n\n//# sourceURL=webpack://InfiniteTree/./lib/extend.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar InfiniteTree = __webpack_require__(/*! ./infinite-tree */ \"./lib/infinite-tree.js\")[\"default\"];\nmodule.exports = InfiniteTree;\n\n//# sourceURL=webpack://InfiniteTree/./lib/index.js?");

/***/ }),

/***/ "./lib/infinite-tree.js":
/*!******************************!*\
  !*** ./lib/infinite-tree.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _events = _interopRequireDefault(__webpack_require__(/*! events */ \"./node_modules/events/events.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\"));\nvar _elementClass = _interopRequireDefault(__webpack_require__(/*! element-class */ \"./node_modules/element-class/index.js\"));\nvar _isDom = _interopRequireDefault(__webpack_require__(/*! is-dom */ \"./node_modules/is-dom/index.js\"));\nvar _flattree = __webpack_require__(/*! flattree */ \"./node_modules/flattree/lib/index.js\");\nvar _clusterize = _interopRequireDefault(__webpack_require__(/*! ./clusterize */ \"./lib/clusterize.js\"));\nvar _ensureArray = _interopRequireDefault(__webpack_require__(/*! ./ensure-array */ \"./lib/ensure-array.js\"));\nvar _extend = _interopRequireDefault(__webpack_require__(/*! ./extend */ \"./lib/extend.js\"));\nvar _lookupTable = _interopRequireDefault(__webpack_require__(/*! ./lookup-table */ \"./lib/lookup-table.js\"));\nvar _removeArrayItems = _interopRequireDefault(__webpack_require__(/*! ./remove-array-items */ \"./lib/remove-array-items.js\"));\nvar _renderer = __webpack_require__(/*! ./renderer */ \"./lib/renderer.js\");\nvar _utilities = __webpack_require__(/*! ./utilities */ \"./lib/utilities.js\");\nvar _dom = __webpack_require__(/*! ./dom */ \"./lib/dom.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } /* eslint no-continue: 0 */ /* eslint operator-assignment: 0 */\nvar noop = function noop() {};\nvar error = function error(format) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  var argIndex = 0;\n  var message = 'Error: ' + format.replace(/%s/g, function () {\n    return args[argIndex++];\n  });\n  if (console && console.error) {\n    console.error(message);\n  }\n  try {\n    // This error was thrown as a convenience so that you can use this stack\n    // to find the callsite that caused this error to fire.\n    throw new Error(message);\n  } catch (e) {\n    // Ignore\n  }\n};\nvar ensureNodeInstance = function ensureNodeInstance(node) {\n  if (!node) {\n    // undefined or null\n    return false;\n  }\n  if (!(node instanceof _flattree.Node)) {\n    error('The node must be a Node object.');\n    return false;\n  }\n  return true;\n};\nvar createRootNode = function createRootNode(rootNode) {\n  return (0, _extend[\"default\"])(rootNode || new _flattree.Node(), {\n    parent: null,\n    children: [],\n    state: {\n      depth: -1,\n      open: true,\n      // always open\n      path: '',\n      prefixMask: '',\n      total: 0\n    }\n  });\n};\nvar InfiniteTree = /*#__PURE__*/function (_events$EventEmitter) {\n  // Creates new InfiniteTree object.\n  function InfiniteTree(el, options) {\n    var _this;\n    _classCallCheck(this, InfiniteTree);\n    _this = _callSuper(this, InfiniteTree);\n    _defineProperty(_this, \"options\", {\n      autoOpen: false,\n      droppable: false,\n      shouldLoadNodes: null,\n      loadNodes: null,\n      rowRenderer: _renderer.defaultRowRenderer,\n      selectable: true,\n      shouldSelectNode: null,\n      // Allow user to define the number of rows, and blocks to be rendered.\n      rowsInBlock: 50,\n      blocksInCluster: 4,\n      // When el is not specified, the tree will run in the stealth mode\n      el: null,\n      // The following options will have no effect in the stealth mode\n      layout: 'div',\n      noDataClass: 'infinite-tree-no-data',\n      noDataText: 'No data',\n      nodeIdAttr: 'data-id',\n      togglerClass: 'infinite-tree-toggler'\n    });\n    _defineProperty(_this, \"state\", {\n      openNodes: [],\n      rootNode: createRootNode(),\n      selectedNode: null\n    });\n    _defineProperty(_this, \"clusterize\", null);\n    _defineProperty(_this, \"nodeTable\", new _lookupTable[\"default\"]());\n    _defineProperty(_this, \"nodes\", []);\n    _defineProperty(_this, \"rows\", []);\n    _defineProperty(_this, \"filtered\", false);\n    // The following elements will have no effect in the stealth mode\n    _defineProperty(_this, \"scrollElement\", null);\n    _defineProperty(_this, \"contentElement\", null);\n    _defineProperty(_this, \"draggableTarget\", null);\n    _defineProperty(_this, \"droppableTarget\", null);\n    _defineProperty(_this, \"contentListener\", {\n      'click': function click(event) {\n        event = event || window.event;\n\n        // Wrap stopPropagation that allows click event handler to stop execution\n        // by setting the cancelBubble property\n        var stopPropagation = event.stopPropagation;\n        event.stopPropagation = function () {\n          // Setting the cancelBubble property in browsers that don't support it doesn't hurt.\n          // Of course it doesn't actually cancel the bubbling, but the assignment itself is safe.\n          event.cancelBubble = true;\n          if (stopPropagation) {\n            stopPropagation.call(event);\n          }\n        };\n\n        // Call setTimeout(fn, 0) to re-queues the execution of subsequent calls, it allows the\n        // click event to bubble up to higher level event handlers before handling tree events.\n        setTimeout(function () {\n          // Stop execution if the cancelBubble property is set to true by higher level event handlers\n          if (event.cancelBubble === true) {\n            return;\n          }\n\n          // Emit a \"click\" event\n          _this.emit('click', event);\n\n          // Stop execution if the cancelBubble property is set to true after emitting the click event\n          if (event.cancelBubble === true) {\n            return;\n          }\n          var itemTarget = null;\n          var clickToggler = false;\n          if (event.target) {\n            itemTarget = event.target !== event.currentTarget ? event.target : null;\n          } else if (event.srcElement) {\n            // IE8\n            itemTarget = event.srcElement;\n          }\n          while (itemTarget && itemTarget.parentElement !== _this.contentElement) {\n            if ((0, _elementClass[\"default\"])(itemTarget).has(_this.options.togglerClass)) {\n              clickToggler = true;\n            }\n            itemTarget = itemTarget.parentElement;\n          }\n          if (!itemTarget || itemTarget.hasAttribute('disabled')) {\n            return;\n          }\n          var id = itemTarget.getAttribute(_this.options.nodeIdAttr);\n          var node = _this.getNodeById(id);\n          if (!node) {\n            return;\n          }\n\n          // Click on the toggler to open/close a tree node\n          if (clickToggler) {\n            _this.toggleNode(node, {\n              async: true\n            });\n            return;\n          }\n          _this.selectNode(node); // selectNode will re-render the tree\n        }, 0);\n      },\n      'dblclick': function dblclick(event) {\n        // Emit a \"doubleClick\" event\n        _this.emit('doubleClick', event);\n      },\n      'keydown': function keydown(event) {\n        // Emit a \"keyDown\" event\n        _this.emit('keyDown', event);\n      },\n      'keyup': function keyup(event) {\n        // Emit a \"keyUp\" event\n        _this.emit('keyUp', event);\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/Events/dragstart\n      // The dragstart event is fired when the user starts dragging an element or text selection.\n      'dragstart': function dragstart(event) {\n        event = event || window.event;\n        _this.draggableTarget = event.target || event.srcElement;\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/Events/dragend\n      // The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key).\n      'dragend': function dragend(event) {\n        event = event || window.event;\n        var _this$options$droppab = _this.options.droppable.hoverClass,\n          hoverClass = _this$options$droppab === void 0 ? '' : _this$options$droppab;\n\n        // Draggable\n        _this.draggableTarget = null;\n\n        // Droppable\n        if (_this.droppableTarget) {\n          (0, _elementClass[\"default\"])(_this.droppableTarget).remove(hoverClass);\n          _this.droppableTarget = null;\n        }\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/Events/dragenter\n      // The dragenter event is fired when a dragged element or text selection enters a valid drop target.\n      'dragenter': function dragenter(event) {\n        event = event || window.event;\n        var itemTarget = null;\n        if (event.target) {\n          itemTarget = event.target !== event.currentTarget ? event.target : null;\n        } else if (event.srcElement) {\n          // IE8\n          itemTarget = event.srcElement;\n        }\n        while (itemTarget && itemTarget.parentElement !== _this.contentElement) {\n          itemTarget = itemTarget.parentElement;\n        }\n        if (!itemTarget) {\n          return;\n        }\n        if (_this.droppableTarget === itemTarget) {\n          return;\n        }\n        var _this$options$droppab2 = _this.options.droppable,\n          accept = _this$options$droppab2.accept,\n          _this$options$droppab3 = _this$options$droppab2.hoverClass,\n          hoverClass = _this$options$droppab3 === void 0 ? '' : _this$options$droppab3;\n        (0, _elementClass[\"default\"])(_this.droppableTarget).remove(hoverClass);\n        _this.droppableTarget = null;\n        var canDrop = true; // Defaults to true\n\n        if (typeof accept === 'function') {\n          var id = itemTarget.getAttribute(_this.options.nodeIdAttr);\n          var node = _this.getNodeById(id);\n          canDrop = !!accept.call(_this, event, {\n            type: 'dragenter',\n            draggableTarget: _this.draggableTarget,\n            droppableTarget: itemTarget,\n            node: node\n          });\n        }\n        if (canDrop) {\n          (0, _elementClass[\"default\"])(itemTarget).add(hoverClass);\n          _this.droppableTarget = itemTarget;\n        }\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/Events/dragover\n      // The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds).\n      'dragover': function dragover(event) {\n        event = event || window.event;\n        (0, _dom.preventDefault)(event);\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/Events/drop\n      // The drop event is fired when an element or text selection is dropped on a valid drop target.\n      'drop': function drop(event) {\n        event = event || window.event;\n\n        // prevent default action (open as link for some elements)\n        (0, _dom.preventDefault)(event);\n        if (!(_this.draggableTarget && _this.droppableTarget)) {\n          return;\n        }\n        var _this$options$droppab4 = _this.options.droppable,\n          accept = _this$options$droppab4.accept,\n          drop = _this$options$droppab4.drop,\n          _this$options$droppab5 = _this$options$droppab4.hoverClass,\n          hoverClass = _this$options$droppab5 === void 0 ? '' : _this$options$droppab5;\n        var id = _this.droppableTarget.getAttribute(_this.options.nodeIdAttr);\n        var node = _this.getNodeById(id);\n        var canDrop = true; // Defaults to true\n\n        if (typeof accept === 'function') {\n          canDrop = !!accept.call(_this, event, {\n            type: 'drop',\n            draggableTarget: _this.draggableTarget,\n            droppableTarget: _this.droppableTarget,\n            node: node\n          });\n        }\n        if (canDrop && typeof drop === 'function') {\n          drop.call(_this, event, {\n            draggableTarget: _this.draggableTarget,\n            droppableTarget: _this.droppableTarget,\n            node: node\n          });\n        }\n        (0, _elementClass[\"default\"])(_this.droppableTarget).remove(hoverClass);\n        _this.droppableTarget = null;\n      }\n    });\n    if ((0, _isDom[\"default\"])(el)) {\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        el: el\n      });\n    } else if (el && _typeof(el) === 'object') {\n      options = el;\n    }\n\n    // Assign options\n    _this.options = _objectSpread(_objectSpread({}, _this.options), options);\n    _this.create();\n\n    // Load tree data if it's provided\n    if (_this.options.data) {\n      _this.loadData(_this.options.data);\n    }\n    return _this;\n  }\n  _inherits(InfiniteTree, _events$EventEmitter);\n  return _createClass(InfiniteTree, [{\n    key: \"create\",\n    value: function create() {\n      var _this2 = this;\n      if (this.options.el) {\n        var tag = null;\n        this.scrollElement = document.createElement('div');\n        if (this.options.layout === 'table') {\n          var tableElement = document.createElement('table');\n          tableElement.className = (0, _classnames[\"default\"])('infinite-tree', 'infinite-tree-table');\n          var contentElement = document.createElement('tbody');\n          tableElement.appendChild(contentElement);\n          this.scrollElement.appendChild(tableElement);\n          this.contentElement = contentElement;\n\n          // The tag name for supporting elements\n          tag = 'tr';\n        } else {\n          var _contentElement = document.createElement('div');\n          this.scrollElement.appendChild(_contentElement);\n          this.contentElement = _contentElement;\n\n          // The tag name for supporting elements\n          tag = 'div';\n        }\n        this.scrollElement.className = (0, _classnames[\"default\"])('infinite-tree', 'infinite-tree-scroll');\n        this.contentElement.className = (0, _classnames[\"default\"])('infinite-tree', 'infinite-tree-content');\n        this.options.el.appendChild(this.scrollElement);\n        this.clusterize = new _clusterize[\"default\"]({\n          tag: tag,\n          rows: [],\n          scrollElement: this.scrollElement,\n          contentElement: this.contentElement,\n          emptyText: this.options.noDataText,\n          emptyClass: this.options.noDataClass,\n          rowsInBlock: this.options.rowsInBlock,\n          blocksInCluster: this.options.blocksInCluster\n        });\n        this.clusterize.on('clusterWillChange', function () {\n          _this2.emit('clusterWillChange');\n        });\n        this.clusterize.on('clusterDidChange', function () {\n          _this2.emit('clusterDidChange');\n        });\n        (0, _dom.addEventListener)(this.contentElement, 'click', this.contentListener.click);\n        (0, _dom.addEventListener)(this.contentElement, 'dblclick', this.contentListener.dblclick);\n        (0, _dom.addEventListener)(this.contentElement, 'keydown', this.contentListener.keydown);\n        (0, _dom.addEventListener)(this.contentElement, 'keyup', this.contentListener.keyup);\n        if (this.options.droppable) {\n          (0, _dom.addEventListener)(document, 'dragstart', this.contentListener.dragstart);\n          (0, _dom.addEventListener)(document, 'dragend', this.contentListener.dragend);\n          (0, _dom.addEventListener)(this.contentElement, 'dragenter', this.contentListener.dragenter);\n          (0, _dom.addEventListener)(this.contentElement, 'dragleave', this.contentListener.dragleave);\n          (0, _dom.addEventListener)(this.contentElement, 'dragover', this.contentListener.dragover);\n          (0, _dom.addEventListener)(this.contentElement, 'drop', this.contentListener.drop);\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clear();\n      if (this.options.el) {\n        (0, _dom.removeEventListener)(this.contentElement, 'click', this.contentListener.click);\n        (0, _dom.removeEventListener)(this.contentElement, 'dblclick', this.contentListener.dblclick);\n        (0, _dom.removeEventListener)(this.contentElement, 'keydown', this.contentListener.keydown);\n        (0, _dom.removeEventListener)(this.contentElement, 'keyup', this.contentListener.keyup);\n        if (this.options.droppable) {\n          (0, _dom.removeEventListener)(document, 'dragstart', this.contentListener.dragstart);\n          (0, _dom.removeEventListener)(document, 'dragend', this.contentListener.dragend);\n          (0, _dom.removeEventListener)(this.contentElement, 'dragenter', this.contentListener.dragenter);\n          (0, _dom.removeEventListener)(this.contentElement, 'dragleave', this.contentListener.dragleave);\n          (0, _dom.removeEventListener)(this.contentElement, 'dragover', this.contentListener.dragover);\n          (0, _dom.removeEventListener)(this.contentElement, 'drop', this.contentListener.drop);\n        }\n        if (this.clusterize) {\n          this.clusterize.destroy(true); // True to remove all data from the list\n          this.clusterize = null;\n        }\n\n        // Remove all child nodes\n        while (this.contentElement.firstChild) {\n          this.contentElement.removeChild(this.contentElement.firstChild);\n        }\n        while (this.scrollElement.firstChild) {\n          this.scrollElement.removeChild(this.scrollElement.firstChild);\n        }\n        var containerElement = this.options.el;\n        while (containerElement.firstChild) {\n          containerElement.removeChild(containerElement.firstChild);\n        }\n        this.contentElement = null;\n        this.scrollElement = null;\n      }\n    }\n\n    // Adds an array of new child nodes to a parent node at the specified index.\n    // * If the parent is null or undefined, inserts new childs at the specified index in the top-level.\n    // * If the parent has children, the method adds the new child to it at the specified index.\n    // * If the parent does not have children, the method adds the new child to the parent.\n    // * If the index value is greater than or equal to the number of children in the parent, the method adds the child at the end of the children.\n    // @param {Array} newNodes An array of new child nodes.\n    // @param {number} [index] The 0-based index of where to insert the child node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"addChildNodes\",\n    value: function addChildNodes(newNodes, index, parentNode) {\n      var _this3 = this;\n      newNodes = [].concat(newNodes || []); // Ensure array\n      if (newNodes.length === 0) {\n        return false;\n      }\n      if (_typeof(index) === 'object') {\n        // The 'object' type might be Node or null\n        parentNode = index || this.state.rootNode; // Defaults to rootNode if not specified\n        index = parentNode.children.length;\n      } else {\n        parentNode = parentNode || this.state.rootNode; // Defaults to rootNode if not specified\n      }\n      if (!ensureNodeInstance(parentNode)) {\n        return false;\n      }\n      if (typeof index !== 'number') {\n        index = parentNode.children.length;\n      }\n\n      // Assign parent\n      newNodes.forEach(function (newNode) {\n        newNode.parent = parentNode;\n      });\n\n      // Insert new child node at the specified index\n      parentNode.children.splice.apply(parentNode.children, [index, 0].concat(newNodes));\n\n      // Get the index of the first new node within the array of child nodes\n      index = parentNode.children.indexOf(newNodes[0]);\n      var deleteCount = parentNode.state.total;\n      var nodes = (0, _flattree.flatten)(parentNode.children, {\n        openNodes: this.state.openNodes\n      });\n      var rows = [];\n      // Update rows\n      rows.length = nodes.length;\n      for (var i = 0; i < nodes.length; ++i) {\n        var node = nodes[i];\n        rows[i] = this.options.rowRenderer(node, this.options);\n      }\n      if (parentNode === this.state.rootNode) {\n        this.nodes = nodes;\n        this.rows = rows;\n      } else {\n        var parentOffset = this.nodes.indexOf(parentNode);\n        if (parentOffset >= 0) {\n          if (parentNode.state.open === true) {\n            // Update nodes & rows\n            this.nodes.splice.apply(this.nodes, [parentOffset + 1, deleteCount].concat(nodes));\n            this.rows.splice.apply(this.rows, [parentOffset + 1, deleteCount].concat(rows));\n          }\n\n          // Update the row corresponding to the parent node\n          this.rows[parentOffset] = this.options.rowRenderer(parentNode, this.options);\n        }\n      }\n\n      // Update the lookup table with newly added nodes\n      parentNode.children.slice(index).forEach(function (childNode) {\n        _this3.flattenNode(childNode).forEach(function (node) {\n          if (node.id !== undefined) {\n            _this3.nodeTable.set(node.id, node);\n          }\n        });\n      });\n\n      // Update list\n      this.update();\n      return true;\n    }\n\n    // Adds a new child node to the end of the list of children of a specified parent node.\n    // * If the parent is null or undefined, inserts the child at the specified index in the top-level.\n    // * If the parent has children, the method adds the child as the last child.\n    // * If the parent does not have children, the method adds the child to the parent.\n    // @param {object} newNode The new child node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"appendChildNode\",\n    value: function appendChildNode(newNode, parentNode) {\n      // Defaults to rootNode if the parentNode is not specified\n      parentNode = parentNode || this.state.rootNode;\n      if (!ensureNodeInstance(parentNode)) {\n        return false;\n      }\n      var index = parentNode.children.length;\n      var newNodes = [].concat(newNode || []); // Ensure array\n      return this.addChildNodes(newNodes, index, parentNode);\n    }\n\n    // Checks or unchecks a node.\n    // @param {Node} node The Node object.\n    // @param {boolean} [checked] Whether to check or uncheck the node. If not specified, it will toggle between checked and unchecked state.\n    // @return {boolean} Returns true on success, false otherwise.\n    // @example\n    //\n    // tree.checkNode(node); // toggle checked and unchecked state\n    // tree.checkNode(node, true); // checked=true, indeterminate=false\n    // tree.checkNode(node, false); // checked=false, indeterminate=false\n    //\n    // @doc\n    //\n    // state.checked | state.indeterminate | description\n    // ------------- | ------------------- | -----------\n    // false         | false               | The node and all of its children are unchecked.\n    // true          | false               | The node and all of its children are checked.\n    // true          | true                | The node will appear as indeterminate when the node is checked and some (but not all) of its children are checked.\n  }, {\n    key: \"checkNode\",\n    value: function checkNode(node, checked) {\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n      this.emit('willCheckNode', node);\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      if (nodeIndex < 0) {\n        error('Invalid node index');\n        return false;\n      }\n      if (checked === true) {\n        node.state.checked = true;\n        node.state.indeterminate = false;\n      } else if (checked === false) {\n        node.state.checked = false;\n        node.state.indeterminate = false;\n      } else {\n        node.state.checked = !!node.state.checked;\n        node.state.indeterminate = !!node.state.indeterminate;\n        node.state.checked = node.state.checked && node.state.indeterminate || !node.state.checked;\n        node.state.indeterminate = false;\n      }\n      var topmostNode = node;\n      var updateChildNodes = function updateChildNodes(parentNode) {\n        var childNode = parentNode.getFirstChild(); // Ignore parent node\n        while (childNode) {\n          // Update checked and indeterminate state\n          childNode.state.checked = parentNode.state.checked;\n          childNode.state.indeterminate = false;\n          if (childNode.hasChildren()) {\n            childNode = childNode.getFirstChild();\n          } else {\n            // Find the parent level\n            while (childNode.getNextSibling() === null && childNode.parent !== parentNode) {\n              // Use child-parent link to get to the parent level\n              childNode = childNode.getParent();\n            }\n\n            // Get next sibling\n            childNode = childNode.getNextSibling();\n          }\n        }\n      };\n      var updateParentNodes = function updateParentNodes(childNode) {\n        var parentNode = childNode.parent;\n        while (parentNode && parentNode.state.depth >= 0) {\n          topmostNode = parentNode;\n          var checkedCount = 0;\n          var indeterminate = false;\n          var len = parentNode.children ? parentNode.children.length : 0;\n          for (var i = 0; i < len; ++i) {\n            var _childNode = parentNode.children[i];\n            indeterminate = indeterminate || !!_childNode.state.indeterminate;\n            if (_childNode.state.checked) {\n              checkedCount++;\n            }\n          }\n          if (checkedCount === 0) {\n            parentNode.state.indeterminate = false;\n            parentNode.state.checked = false;\n          } else if (checkedCount > 0 && checkedCount < len || indeterminate) {\n            parentNode.state.indeterminate = true;\n            parentNode.state.checked = true;\n          } else {\n            parentNode.state.indeterminate = false;\n            parentNode.state.checked = true;\n          }\n          parentNode = parentNode.parent;\n        }\n      };\n      updateChildNodes(node);\n      updateParentNodes(node);\n      this.updateNode(topmostNode);\n\n      // Emit a \"checkNode\" event\n      this.emit('checkNode', node);\n      return true;\n    }\n\n    // Clears the tree.\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.clusterize) {\n        this.clusterize.clear();\n      }\n      this.nodeTable.clear();\n      this.nodes = [];\n      this.rows = [];\n      this.state.openNodes = [];\n      this.state.rootNode = createRootNode(this.state.rootNode);\n      this.state.selectedNode = null;\n    }\n\n    // Closes a node to hide its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"closeNode\" and \"selectNode\" events from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"closeNode\",\n    value: function closeNode(node, options) {\n      var _this4 = this;\n      var _options = _objectSpread({}, options),\n        _options$async = _options.async,\n        async = _options$async === void 0 ? false : _options$async,\n        _options$asyncCallbac = _options.asyncCallback,\n        asyncCallback = _options$asyncCallbac === void 0 ? noop : _options$asyncCallbac,\n        _options$silent = _options.silent,\n        silent = _options$silent === void 0 ? false : _options$silent;\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n      this.emit('willCloseNode', node);\n\n      // Cannot close the root node\n      if (node === this.state.rootNode) {\n        error('Cannot close the root node');\n        return false;\n      }\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      if (nodeIndex < 0) {\n        error('Invalid node index');\n        return false;\n      }\n\n      // Check if the closeNode action can be performed\n      if (this.state.openNodes.indexOf(node) < 0) {\n        return false;\n      }\n\n      // Toggle the collapsing state\n      node.state.collapsing = true;\n      // Update the row corresponding to the node\n      this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n      // Update list\n      this.update();\n      var fn = function fn() {\n        // Keep selected node unchanged if \"node\" is equal to \"this.state.selectedNode\"\n        if (_this4.state.selectedNode && _this4.state.selectedNode !== node) {\n          // row #0 - node.0         => parent node (total=4)\n          // row #1   - node.0.0     => close this node; next selected node (total=2)\n          // row #2       node.0.0.0 => selected node (total=0)\n          // row #3       node.0.0.1\n          // row #4     node.0.1\n          var selectedIndex = _this4.nodes.indexOf(_this4.state.selectedNode);\n          var _total = node.state.total;\n          var rangeFrom = nodeIndex + 1;\n          var rangeTo = nodeIndex + _total;\n          if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n            _this4.selectNode(node, options);\n          }\n        }\n        node.state.open = false; // Set the open state to false\n        var openNodes = _this4.state.openNodes.filter(function (node) {\n          return node.state.open;\n        });\n        _this4.state.openNodes = openNodes;\n\n        // Subtract total from ancestor nodes\n        var total = node.state.total;\n        for (var p = node; p !== null; p = p.parent) {\n          p.state.total = p.state.total - total;\n        }\n\n        // Update nodes & rows\n        (0, _removeArrayItems[\"default\"])(_this4.nodes, nodeIndex + 1, total);\n        (0, _removeArrayItems[\"default\"])(_this4.rows, nodeIndex + 1, total);\n\n        // Toggle the collapsing state\n        node.state.collapsing = false;\n        // Update the row corresponding to the node\n        _this4.rows[nodeIndex] = _this4.options.rowRenderer(node, _this4.options);\n\n        // Update list\n        _this4.update();\n        if (!silent) {\n          // Emit a \"closeNode\" event\n          _this4.emit('closeNode', node);\n        }\n        if (typeof asyncCallback === 'function') {\n          asyncCallback();\n        }\n      };\n      if (async) {\n        setTimeout(fn, 0);\n      } else {\n        fn();\n      }\n      return true;\n    }\n\n    // Filters nodes. Use a string or a function to test each node of the tree. Otherwise, it will render nothing after filtering (e.g. tree.filter(), tree.filter(null), tree.flter(0), tree.filter({}), etc.).\n    // @param {string|function} predicate A keyword string, or a function to test each node of the tree. If the predicate is an empty string, all nodes will be filtered. If the predicate is a function, returns true to keep the node, false otherwise.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.caseSensitive] Case sensitive string comparison. Defaults to false. This option is only available for string comparison.\n    // @param {boolean} [options.exactMatch] Exact string matching. Defaults to false. This option is only available for string comparison.\n    // @param {string} [options.filterPath] Gets the value at path of Node object. Defaults to 'name'. This option is only available for string comparison.\n    // @param {boolean} [options.includeAncestors] Whether to include ancestor nodes. Defaults to true.\n    // @param {boolean} [options.includeDescendants] Whether to include descendant nodes. Defaults to true.\n    // @example\n    //\n    // const filterOptions = {\n    //     caseSensitive: false,\n    //     exactMatch: false,\n    //     filterPath: 'props.some.other.key',\n    //     includeAncestors: true,\n    //     includeDescendants: true\n    // };\n    // tree.filter('keyword', filterOptions);\n    //\n    // @example\n    //\n    // const filterOptions = {\n    //     includeAncestors: true,\n    //     includeDescendants: true\n    // };\n    // tree.filter(function(node) {\n    //     const keyword = 'keyword';\n    //     const filterText = node.name || '';\n    //     return filterText.toLowerCase().indexOf(keyword) >= 0;\n    // }, filterOptions);\n  }, {\n    key: \"filter\",\n    value: function filter(predicate, options) {\n      options = _objectSpread({\n        caseSensitive: false,\n        exactMatch: false,\n        filterPath: 'name',\n        includeAncestors: true,\n        includeDescendants: true\n      }, options);\n      this.filtered = true;\n      var rootNode = this.state.rootNode;\n      var traverse = function traverse(node) {\n        var filterNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!node || !node.children) {\n          return false;\n        }\n        if (node === rootNode) {\n          node.state.filtered = false;\n        } else if (filterNode) {\n          node.state.filtered = true;\n        } else if (typeof predicate === 'string') {\n          // string\n          var filterText = (0, _utilities.get)(node, options.filterPath, '');\n          if (Number.isFinite(filterText)) {\n            filterText = String(filterText);\n          }\n          if (typeof filterText !== 'string') {\n            filterText = '';\n          }\n          var keyword = predicate;\n          if (!options.caseSensitive) {\n            filterText = filterText.toLowerCase();\n            keyword = keyword.toLowerCase();\n          }\n          node.state.filtered = options.exactMatch ? filterText === keyword : filterText.indexOf(keyword) >= 0;\n        } else if (typeof predicate === 'function') {\n          // function\n          var callback = predicate;\n          node.state.filtered = !!callback(node);\n        } else {\n          node.state.filtered = false;\n        }\n        if (options.includeDescendants) {\n          filterNode = filterNode || node.state.filtered;\n        }\n        var filtered = false;\n        for (var i = 0; i < node.children.length; ++i) {\n          var childNode = node.children[i];\n          if (!childNode) {\n            continue;\n          }\n          if (traverse(childNode, filterNode)) {\n            filtered = true;\n          }\n        }\n        if (options.includeAncestors && filtered) {\n          node.state.filtered = true;\n        }\n        return node.state.filtered;\n      };\n      traverse(rootNode);\n\n      // Update rows\n      this.rows.length = this.nodes.length;\n      for (var i = 0; i < this.nodes.length; ++i) {\n        var node = this.nodes[i];\n        this.rows[i] = this.options.rowRenderer(node, this.options);\n      }\n      this.update();\n    }\n\n    // Flattens all child nodes of a parent node by performing full tree traversal using child-parent link.\n    // No recursion or stack is involved.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {array} Returns an array of Node objects containing all the child nodes of the parent node.\n  }, {\n    key: \"flattenChildNodes\",\n    value: function flattenChildNodes(parentNode) {\n      // Defaults to rootNode if the parentNode is not specified\n      parentNode = parentNode || this.state.rootNode;\n      if (!ensureNodeInstance(parentNode)) {\n        return [];\n      }\n      var list = [];\n      var node = parentNode.getFirstChild(); // Ignore parent node\n      while (node) {\n        list.push(node);\n        if (node.hasChildren()) {\n          node = node.getFirstChild();\n        } else {\n          // Find the parent level\n          while (node.getNextSibling() === null && node.parent !== parentNode) {\n            // Use child-parent link to get to the parent level\n            node = node.getParent();\n          }\n\n          // Get next sibling\n          node = node.getNextSibling();\n        }\n      }\n      return list;\n    }\n\n    // Flattens a node by performing full tree traversal using child-parent link.\n    // No recursion or stack is involved.\n    // @param {Node} node The Node object.\n    // @return {array} Returns a flattened list of Node objects.\n  }, {\n    key: \"flattenNode\",\n    value: function flattenNode(node) {\n      if (!ensureNodeInstance(node)) {\n        return [];\n      }\n      return [node].concat(this.flattenChildNodes(node));\n    }\n\n    // Gets a list of child nodes.\n    // @param {Node} [parentNode] The Node object that defines the parent node. If null or undefined, returns a list of top level nodes.\n    // @return {array} Returns an array of Node objects containing all the child nodes of the parent node.\n  }, {\n    key: \"getChildNodes\",\n    value: function getChildNodes(parentNode) {\n      // Defaults to rootNode if the parentNode is not specified\n      parentNode = parentNode || this.state.rootNode;\n      if (!ensureNodeInstance(parentNode)) {\n        return [];\n      }\n      return parentNode.children;\n    }\n\n    // Gets a node by its unique id. This assumes that you have given the nodes in the data a unique id.\n    // @param {string|number} id An unique node id. A null value will be returned if the id doesn't match.\n    // @return {Node} Returns a node the matches the id, null otherwise.\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      var node = this.nodeTable.get(id);\n      if (!node) {\n        // Find the first node that matches the id\n        node = this.nodes.filter(function (node) {\n          return node.id === id;\n        })[0];\n        if (!node) {\n          return null;\n        }\n        this.nodeTable.set(node.id, node);\n      }\n      return node;\n    }\n\n    // Returns the node at the specified point. If the specified point is outside the visible bounds or either coordinate is negative, the result is null.\n    // @param {number} x A horizontal position within the current viewport.\n    // @param {number} y A vertical position within the current viewport.\n    // @return {Node} The Node object under the given point.\n  }, {\n    key: \"getNodeFromPoint\",\n    value: function getNodeFromPoint(x, y) {\n      var el = document.elementFromPoint(x, y);\n      while (el && el.parentElement !== this.contentElement) {\n        el = el.parentElement;\n      }\n      if (!el) {\n        return null;\n      }\n      var id = el.getAttribute(this.options.nodeIdAttr);\n      var node = this.getNodeById(id);\n      return node;\n    }\n\n    // Gets an array of open nodes.\n    // @return {array} Returns an array of Node objects containing open nodes.\n  }, {\n    key: \"getOpenNodes\",\n    value: function getOpenNodes() {\n      // returns a shallow copy of an array into a new array object.\n      return this.state.openNodes.slice();\n    }\n\n    // Gets the root node.\n    // @return {Node} Returns the root node, or null if empty.\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode() {\n      return this.state.rootNode;\n    }\n\n    // Gets the selected node.\n    // @return {Node} Returns the selected node, or null if not selected.\n  }, {\n    key: \"getSelectedNode\",\n    value: function getSelectedNode() {\n      return this.state.selectedNode;\n    }\n\n    // Gets the index of the selected node.\n    // @return {number} Returns the index of the selected node, or -1 if not selected.\n  }, {\n    key: \"getSelectedIndex\",\n    value: function getSelectedIndex() {\n      return this.nodes.indexOf(this.state.selectedNode);\n    }\n\n    // Inserts the specified node after the reference node.\n    // @param {object} newNode The new sibling node.\n    // @param {Node} referenceNode The Node object that defines the reference node.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, referenceNode) {\n      if (!ensureNodeInstance(referenceNode)) {\n        return false;\n      }\n      var parentNode = referenceNode.getParent();\n      var index = parentNode.children.indexOf(referenceNode) + 1;\n      var newNodes = [].concat(newNode || []); // Ensure array\n\n      return this.addChildNodes(newNodes, index, parentNode);\n    }\n\n    // Inserts the specified node before the reference node.\n    // @param {object} newNode The new sibling node.\n    // @param {Node} referenceNode The Node object that defines the reference node.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, referenceNode) {\n      if (!ensureNodeInstance(referenceNode)) {\n        return false;\n      }\n      var parentNode = referenceNode.getParent();\n      var index = parentNode.children.indexOf(referenceNode);\n      var newNodes = [].concat(newNode || []); // Ensure array\n\n      return this.addChildNodes(newNodes, index, parentNode);\n    }\n\n    // Loads data in the tree.\n    // @param {object|array} data The data is an object or array of objects that defines the node.\n  }, {\n    key: \"loadData\",\n    value: function loadData() {\n      var _this5 = this;\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.nodes = (0, _flattree.flatten)(data, {\n        openAllNodes: this.options.autoOpen\n      });\n\n      // Clear lookup table\n      this.nodeTable.clear();\n      this.state.openNodes = this.nodes.filter(function (node) {\n        return node.state.open;\n      });\n      this.state.selectedNode = null;\n      var rootNode = function () {\n        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        // Finding the root node\n        while (node && node.parent !== null) {\n          node = node.parent;\n        }\n        return node;\n      }(this.nodes.length > 0 ? this.nodes[0] : null);\n      this.state.rootNode = rootNode || createRootNode(this.state.rootNode); // Create a new root node if rootNode is null\n\n      // Update the lookup table with newly added nodes\n      this.flattenChildNodes(this.state.rootNode).forEach(function (node) {\n        if (node.id !== undefined) {\n          _this5.nodeTable.set(node.id, node);\n        }\n      });\n\n      // Update rows\n      this.rows.length = this.nodes.length;\n      for (var i = 0; i < this.nodes.length; ++i) {\n        var node = this.nodes[i];\n        this.rows[i] = this.options.rowRenderer(node, this.options);\n      }\n\n      // Update list\n      this.update();\n    }\n\n    // Moves a node from its current position to the new position.\n    // @param {Node} node The Node object.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @param {number} [index] The 0-based index of where to insert the child node.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"moveNodeTo\",\n    value: function moveNodeTo(node, parentNode, index) {\n      if (!ensureNodeInstance(node) || !ensureNodeInstance(parentNode)) {\n        return false;\n      }\n      for (var p = parentNode; p !== null; p = p.parent) {\n        if (p === node) {\n          error(\"Cannot move an ancestor node (id=\".concat(node.id, \") to the specified parent node (id=\").concat(parentNode.id, \").\"));\n          return false;\n        }\n      }\n      return this.removeNode(node) && this.addChildNodes(node, index, parentNode);\n    }\n\n    // Opens a node to display its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"openNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"openNode\",\n    value: function openNode(node, options) {\n      var _this6 = this;\n      var _options2 = _objectSpread({}, options),\n        _options2$async = _options2.async,\n        async = _options2$async === void 0 ? false : _options2$async,\n        _options2$asyncCallba = _options2.asyncCallback,\n        asyncCallback = _options2$asyncCallba === void 0 ? noop : _options2$asyncCallba,\n        _options2$silent = _options2.silent,\n        silent = _options2$silent === void 0 ? false : _options2$silent;\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n      if (!this.nodeTable.has(node.id)) {\n        error('Cannot open node with the given node id:', node.id);\n        return false;\n      }\n\n      // Check if the openNode action can be performed\n      if (this.state.openNodes.indexOf(node) >= 0) {\n        return false;\n      }\n      this.emit('willOpenNode', node);\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      var fn = function fn() {\n        node.state.open = true;\n        if (_this6.state.openNodes.indexOf(node) < 0) {\n          // the most recently used items first\n          _this6.state.openNodes = [node].concat(_this6.state.openNodes);\n        }\n        var nodes = (0, _flattree.flatten)(node.children, {\n          openNodes: _this6.state.openNodes\n        });\n\n        // Add all child nodes to the lookup table if the first child does not exist in the lookup table\n        if (nodes.length > 0 && !_this6.nodeTable.get(nodes[0])) {\n          nodes.forEach(function (node) {\n            if (node.id !== undefined) {\n              _this6.nodeTable.set(node.id, node);\n            }\n          });\n        }\n\n        // Toggle the expanding state\n        node.state.expanding = false;\n        if (nodeIndex >= 0) {\n          var rows = [];\n          // Update rows\n          rows.length = nodes.length;\n          for (var i = 0; i < nodes.length; ++i) {\n            var _node = nodes[i];\n            rows[i] = _this6.options.rowRenderer(_node, _this6.options);\n          }\n\n          // Update nodes & rows\n          _this6.nodes.splice.apply(_this6.nodes, [nodeIndex + 1, 0].concat(nodes));\n          _this6.rows.splice.apply(_this6.rows, [nodeIndex + 1, 0].concat(rows));\n\n          // Update the row corresponding to the node\n          _this6.rows[nodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n\n          // Update list\n          _this6.update();\n        }\n        if (!silent) {\n          // Emit a \"openNode\" event\n          _this6.emit('openNode', node);\n        }\n        if (typeof asyncCallback === 'function') {\n          asyncCallback();\n        }\n      };\n      if (nodeIndex < 0) {\n        // Toggle the expanding state\n        node.state.expanding = true;\n        if (async) {\n          setTimeout(fn, 0);\n        } else {\n          fn();\n        }\n        return true;\n      }\n      var shouldLoadNodes = typeof this.options.shouldLoadNodes === 'function' ? !!this.options.shouldLoadNodes(node) : !node.hasChildren() && node.loadOnDemand;\n      if (shouldLoadNodes) {\n        if (typeof this.options.loadNodes !== 'function') {\n          return false;\n        }\n\n        // Reentrancy not allowed\n        if (node.state.loading === true) {\n          return false;\n        }\n\n        // Toggle the loading state\n        node.state.loading = true;\n        // Update the row corresponding to the node\n        this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n        // Update list\n        this.update();\n\n        // Do a setTimeout to prevent the CPU intensive task\n        setTimeout(function () {\n          _this6.options.loadNodes(node, function (err, nodes) {\n            var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n            nodes = (0, _ensureArray[\"default\"])(nodes);\n            var currentNodeIndex = _this6.nodes.indexOf(node);\n            if (nodes.length === 0 && currentNodeIndex >= 0) {\n              node.state.open = true;\n              if (_this6.state.openNodes.indexOf(node) < 0) {\n                // the most recently used items first\n                _this6.state.openNodes = [node].concat(_this6.state.openNodes);\n              }\n            }\n            if (err || nodes.length === 0) {\n              // Toggle the loading state\n              node.state.loading = false;\n              // Update the row corresponding to the node\n              _this6.rows[currentNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n              // Update list\n              _this6.update();\n              if (typeof done === 'function') {\n                done();\n              }\n              return;\n            }\n            _this6.addChildNodes(nodes, node);\n\n            // Ensure the node has children to prevent infinite loop\n            if (node.hasChildren()) {\n              // Call openNode again\n              _this6.openNode(node, _objectSpread(_objectSpread({}, options), {}, {\n                async: true,\n                asyncCallback: function asyncCallback() {\n                  // Toggle the loading state\n                  node.state.loading = false;\n                  var openedNodeIndex = _this6.nodes.indexOf(node);\n                  // Update the row corresponding to the node\n                  _this6.rows[openedNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n                  // Update list\n                  _this6.update();\n                  if (typeof done === 'function') {\n                    done();\n                  }\n                }\n              }));\n            } else {\n              // Toggle the loading state\n              node.state.loading = false;\n              // Update the row corresponding to the node\n              _this6.rows[currentNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n              // Update list\n              _this6.update();\n              if (typeof done === 'function') {\n                done();\n              }\n            }\n          });\n        }, 0);\n        return true;\n      }\n\n      // Toggle the expanding state\n      node.state.expanding = true;\n\n      // Update the row corresponding to the node\n      this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n      // Update list\n      this.update();\n      if (async) {\n        setTimeout(fn, 0);\n      } else {\n        fn();\n      }\n      return true;\n    }\n\n    // Removes all child nodes from a parent node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"removeChildNodes\",\n    value: function removeChildNodes(parentNode, options) {\n      var _this7 = this;\n      if (!ensureNodeInstance(parentNode)) {\n        return false;\n      }\n      if (parentNode.children.length === 0) {\n        return false;\n      }\n      if (parentNode === this.state.rootNode) {\n        this.clear();\n        return true;\n      }\n      var parentNodeIndex = this.nodes.indexOf(parentNode);\n\n      // Update selected node\n      if (parentNodeIndex >= 0 && this.state.selectedNode) {\n        // row #0 - node.0         => parent node (total=4)\n        // row #1   - node.0.0\n        // row #2       node.0.0.0 => current selected node\n        // row #3       node.0.0.1\n        // row #4     node.0.1\n        var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n        var rangeFrom = parentNodeIndex + 1;\n        var rangeTo = parentNodeIndex + parentNode.state.total;\n        if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n          if (parentNode === this.state.rootNode) {\n            this.selectNode(null, options);\n          } else {\n            this.selectNode(parentNode, options);\n          }\n        }\n      }\n\n      // Get the nodes being removed\n      var removedNodes = this.flattenChildNodes(parentNode);\n\n      // Get the number of nodes to be removed\n      var deleteCount = parentNode.state.total;\n\n      // Subtract the deleteCount for all ancestors (parent, grandparent, etc.) of the current node\n      for (var p = parentNode; p !== null; p = p.parent) {\n        p.state.total = p.state.total - deleteCount;\n      }\n\n      // Update parent node\n      parentNode.children = [];\n      if (parentNode !== this.state.rootNode) {\n        parentNode.state.open = parentNode.state.open && parentNode.children.length > 0;\n      }\n      if (parentNodeIndex >= 0) {\n        // Update nodes & rows\n        (0, _removeArrayItems[\"default\"])(this.nodes, parentNodeIndex + 1, deleteCount);\n        (0, _removeArrayItems[\"default\"])(this.rows, parentNodeIndex + 1, deleteCount);\n\n        // Update the row corresponding to the parent node\n        this.rows[parentNodeIndex] = this.options.rowRenderer(parentNode, this.options);\n      }\n      {\n        // Update open nodes and lookup table\n        this.state.openNodes = this.state.openNodes.filter(function (node) {\n          return removedNodes.indexOf(node) < 0 && node.state.open;\n        });\n        removedNodes.forEach(function (node) {\n          _this7.nodeTable.unset(node.id);\n        });\n      }\n\n      // Update list\n      this.update();\n      return true;\n    }\n\n    // Removes a node and all of its child nodes.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(node, options) {\n      var _this8 = this;\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n      var parentNode = node.parent;\n      if (!parentNode) {\n        return false;\n      }\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      var parentNodeIndex = this.nodes.indexOf(parentNode);\n\n      // Update selected node\n      if (nodeIndex >= 0 && this.state.selectedNode) {\n        // row #0 - node.0         => parent node (total=4)\n        // row #1   - node.0.0     => remove this node (total=2)\n        // row #2       node.0.0.0 => current selected node (total=0)\n        // row #3       node.0.0.1\n        // row #4     node.0.1     => next selected node (total=0)\n        var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n        var rangeFrom = nodeIndex;\n        var rangeTo = nodeIndex + node.state.total + 1;\n        if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n          // Change the selected node in the following order:\n          // 1. next sibling node\n          // 2. previous sibling node\n          // 3. parent node\n          var selectedNode = node.getNextSibling() || node.getPreviousSibling() || node.getParent();\n          if (selectedNode === this.state.rootNode) {\n            this.selectNode(null, options);\n          } else {\n            this.selectNode(selectedNode, options);\n          }\n        }\n      }\n\n      // Get the nodes being removed\n      var removedNodes = this.flattenNode(node);\n\n      // Get the number of nodes to be removed\n      var deleteCount = node.state.total + 1;\n\n      // Subtract the deleteCount for all ancestors (parent, grandparent, etc.) of the current node\n      for (var p = parentNode; p !== null; p = p.parent) {\n        p.state.total = p.state.total - deleteCount;\n      }\n\n      // Update parent node\n      (0, _removeArrayItems[\"default\"])(parentNode.children, parentNode.children.indexOf(node), 1);\n      if (parentNode !== this.state.rootNode) {\n        parentNode.state.open = parentNode.state.open && parentNode.children.length > 0;\n      }\n      if (nodeIndex >= 0) {\n        // Update nodes & rows\n        (0, _removeArrayItems[\"default\"])(this.nodes, nodeIndex, deleteCount);\n        (0, _removeArrayItems[\"default\"])(this.rows, nodeIndex, deleteCount);\n      }\n\n      // Update the row corresponding to the parent node\n      if (parentNodeIndex >= 0) {\n        this.rows[parentNodeIndex] = this.options.rowRenderer(parentNode, this.options);\n      }\n      {\n        // Update open nodes and lookup table\n        this.state.openNodes = this.state.openNodes.filter(function (node) {\n          return removedNodes.indexOf(node) < 0 && node.state.open;\n        });\n        removedNodes.forEach(function (node) {\n          _this8.nodeTable.unset(node.id);\n        });\n      }\n\n      // Update list\n      this.update();\n      return true;\n    }\n\n    // Sets the current scroll position to this node.\n    // @param {Node} node The Node object.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"scrollToNode\",\n    value: function scrollToNode(node) {\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      if (nodeIndex < 0) {\n        return false;\n      }\n      if (!this.contentElement) {\n        return false;\n      }\n\n      // Scroll to a desired position\n      var prefix = 'infinite-tree-';\n      var firstChild = this.contentElement.firstChild;\n      while (firstChild) {\n        var className = firstChild.className || '';\n        if (className.indexOf(prefix + 'extra-row') < 0 && firstChild.offsetHeight > 0) {\n          break;\n        }\n        firstChild = firstChild.nextSibling;\n      }\n      // If all items in the list is the same height, it can be calculated by nodeIndex * height.\n      var itemHeight = firstChild && firstChild.getBoundingClientRect().height || 0;\n      if (itemHeight > 0) {\n        this.scrollTop(nodeIndex * itemHeight);\n      }\n\n      // Find the absolute position of the node\n      var nodeSelector = \"[\".concat(this.options.nodeIdAttr, \"=\\\"\").concat(node.id, \"\\\"]\");\n      var nodeEl = this.contentElement.querySelector(nodeSelector);\n      if (nodeEl) {\n        this.scrollTop(nodeEl.offsetTop);\n      }\n      return true;\n    }\n\n    // Gets (or sets) the current vertical position of the scroll bar.\n    // @param {number} [value] If the value is specified, indicates the new position to set the scroll bar to.\n    // @return {number} Returns the vertical scroll position.\n  }, {\n    key: \"scrollTop\",\n    value: function scrollTop(value) {\n      if (!this.scrollElement) {\n        return 0;\n      }\n      if (value !== undefined) {\n        this.scrollElement.scrollTop = Number(value);\n      }\n      return this.scrollElement.scrollTop;\n    }\n\n    // Selects a node.\n    // @param {Node} node The Node object. If null or undefined, deselects the current node.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.autoScroll] Pass true to automatically scroll to the selected node. Defaults to true.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered. Defaults to false.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"selectNode\",\n    value: function selectNode() {\n      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      var _this$options = this.options,\n        selectable = _this$options.selectable,\n        shouldSelectNode = _this$options.shouldSelectNode;\n      var _options3 = _objectSpread({}, options),\n        _options3$autoScroll = _options3.autoScroll,\n        autoScroll = _options3$autoScroll === void 0 ? true : _options3$autoScroll,\n        _options3$silent = _options3.silent,\n        silent = _options3$silent === void 0 ? false : _options3$silent;\n      this.emit('willSelectNode', node);\n      if (!selectable) {\n        return false;\n      }\n      if (typeof shouldSelectNode === 'function' && !shouldSelectNode(node)) {\n        return false;\n      }\n      if (node === this.state.rootNode) {\n        return false;\n      }\n      if (node === null) {\n        // Deselect the current node\n        if (this.state.selectedNode) {\n          var selectedNode = this.state.selectedNode;\n          var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n          selectedNode.state.selected = false;\n          this.rows[selectedIndex] = this.options.rowRenderer(selectedNode, this.options);\n          this.state.selectedNode = null;\n\n          // Update list\n          this.update();\n          if (!silent) {\n            // Emit a \"selectNode\" event\n            this.emit('selectNode', null);\n          }\n          return true;\n        }\n        return false;\n      }\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      if (nodeIndex < 0) {\n        return false;\n      }\n\n      // Select this node\n      if (this.state.selectedNode !== node) {\n        node.state.selected = true;\n\n        // Update the row corresponding to the node\n        this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n      }\n\n      // Deselect the current node\n      if (this.state.selectedNode) {\n        var _selectedNode = this.state.selectedNode;\n        var _selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n        _selectedNode.state.selected = false;\n        this.rows[_selectedIndex] = this.options.rowRenderer(_selectedNode, this.options);\n      }\n      if (this.state.selectedNode !== node) {\n        this.state.selectedNode = node;\n        if (!silent) {\n          // Emit a \"selectNode\" event\n          this.emit('selectNode', node);\n        }\n        if (autoScroll && this.scrollElement && this.contentElement) {\n          var nodeSelector = \"[\".concat(this.options.nodeIdAttr, \"=\\\"\").concat(node.id, \"\\\"]\");\n          var nodeEl = this.contentElement.querySelector(nodeSelector);\n          if (nodeEl) {\n            var offsetTop = nodeEl.offsetTop || 0;\n            var itemHeight = nodeEl.getBoundingClientRect().height || 0;\n\n            // Scroll Up\n            if (offsetTop < this.scrollElement.scrollTop) {\n              this.scrollElement.scrollTop = offsetTop;\n            }\n\n            // Scroll Down\n            if (offsetTop + itemHeight >= this.scrollElement.scrollTop + this.scrollElement.clientHeight) {\n              this.scrollElement.scrollTop += itemHeight;\n            }\n          }\n        }\n      } else {\n        this.state.selectedNode = null;\n        if (!silent) {\n          // Emit a \"selectNode\" event\n          this.emit('selectNode', null);\n        }\n      }\n\n      // Update list\n      this.update();\n      return true;\n    }\n\n    // Swaps two nodes.\n    // @param {Node} node1 The Node object.\n    // @param {Node} node2 The Node object.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"swapNodes\",\n    value: function swapNodes(node1, node2) {\n      if (!ensureNodeInstance(node1) || !ensureNodeInstance(node1.parent)) {\n        return false;\n      }\n      if (!ensureNodeInstance(node2) || !ensureNodeInstance(node2.parent)) {\n        return false;\n      }\n      var parentNode1 = node1.parent;\n      var parentNode2 = node2.parent;\n      for (var p = parentNode1; p !== null; p = p.parent) {\n        if (p === node2) {\n          error('Cannot swap two nodes with one being an ancestor of the other.');\n          return false;\n        }\n      }\n      for (var _p = parentNode2; _p !== null; _p = _p.parent) {\n        if (_p === node1) {\n          error('Cannot swap two nodes with one being an ancestor of the other.');\n          return false;\n        }\n      }\n      var nodeIndex1 = parentNode1.children.indexOf(node1);\n      var nodeIndex2 = parentNode2.children.indexOf(node2);\n      return this.moveNodeTo(node1, parentNode2, nodeIndex2) && this.moveNodeTo(node2, parentNode1, nodeIndex1);\n    }\n\n    // Toggles a node to display or hide its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"closeNode\", \"openNode\", and \"selectNode\" events from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n  }, {\n    key: \"toggleNode\",\n    value: function toggleNode(node, options) {\n      if (!ensureNodeInstance(node)) {\n        return false;\n      }\n      if (this.state.openNodes.indexOf(node) >= 0) {\n        // Close node\n        return this.closeNode(node, options);\n      } else {\n        // Open node\n        return this.openNode(node, options);\n      }\n    }\n\n    // Serializes the current state of a node to a JSON string.\n    // @param {Node} node The Node object. If null, returns the whole tree.\n    // @return {string} Returns a JSON string represented the tree.\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var traverse = function traverse(node) {\n        var s = '[';\n        if (node && node.children) {\n          var _loop = function _loop(i) {\n            var list = [];\n            s = s + '{';\n            Object.keys(node).forEach(function (key) {\n              var value = node[key];\n              if (key === 'parent') {\n                // ignore parent\n                return;\n              }\n              if (key === 'children') {\n                // traverse child nodes\n                list.push('\"' + key + '\":' + traverse(node.children[i]));\n                return;\n              }\n              if (typeof value === 'string' || _typeof(value) === 'object') {\n                list.push('\"' + key + '\":' + JSON.stringify(value));\n              } else {\n                // primitive types\n                list.push('\"' + key + '\":' + value);\n              }\n            });\n            s = s + list.join(',');\n            s = s + '}' + (i === node.children.length - 1 ? '' : ',');\n          };\n          for (var i = 0; i < node.children.length; ++i) {\n            _loop(i);\n          }\n        }\n        s = s + ']';\n        return s;\n      };\n      if (!node) {\n        node = this.state.rootNode;\n      }\n      return traverse(node);\n    }\n\n    // Unfilters nodes.\n  }, {\n    key: \"unfilter\",\n    value: function unfilter() {\n      this.filtered = false;\n      var rootNode = this.state.rootNode;\n      var traverse = function traverse(node) {\n        if (!node) {\n          return;\n        }\n        delete node.state.filtered;\n        if (!node.children) {\n          return;\n        }\n        for (var i = 0; i < node.children.length; ++i) {\n          var childNode = node.children[i];\n          if (!childNode) {\n            continue;\n          }\n          traverse(childNode);\n        }\n      };\n      traverse(rootNode);\n\n      // Update rows\n      this.rows.length = this.nodes.length;\n      for (var i = 0; i < this.nodes.length; ++i) {\n        var node = this.nodes[i];\n        this.rows[i] = this.options.rowRenderer(node, this.options);\n      }\n      this.update();\n    }\n\n    // Updates the tree.\n  }, {\n    key: \"update\",\n    value: function update() {\n      // Emit a \"contentWillUpdate\" event\n      this.emit('contentWillUpdate');\n      if (this.clusterize) {\n        // Update list\n        var rows = this.rows.filter(function (row) {\n          return !!row;\n        });\n        this.clusterize.update(rows);\n      }\n\n      // Emit a \"contentWillUpdate\" event\n      this.emit('contentDidUpdate');\n    }\n\n    // Updates the data of a node.\n    // @param {Node} node The Node object.\n    // @param {object} data The data object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.shallowRendering] True to render only the parent node, false to render the parent node and all expanded child nodes. Defaults to false.\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(node, data, options) {\n      if (!ensureNodeInstance(node)) {\n        return;\n      }\n\n      // Clone a new one\n      data = _objectSpread({}, data);\n      if (data.id !== undefined && data.id !== null) {\n        this.nodeTable.unset(node.id);\n        this.nodeTable.set(data.id, node);\n        node.id = data.id;\n      }\n\n      // Ignore keys: id, children, parent, and state\n      delete data.id;\n      delete data.children;\n      delete data.parent;\n      delete data.state;\n      node = (0, _extend[\"default\"])(node, data);\n\n      // Retrieve node index\n      var nodeIndex = this.nodes.indexOf(node);\n      if (nodeIndex >= 0) {\n        var _options4 = _objectSpread({}, options),\n          _options4$shallowRend = _options4.shallowRendering,\n          shallowRendering = _options4$shallowRend === void 0 ? false : _options4$shallowRend;\n\n        // Update the row corresponding to the node\n        this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n        if (!shallowRendering) {\n          var total = node.state.total;\n          var rangeFrom = nodeIndex + 1;\n          var rangeTo = nodeIndex + total;\n          for (var index = rangeFrom; index <= rangeTo; ++index) {\n            this.rows[index] = this.options.rowRenderer(this.nodes[index], this.options);\n          }\n        }\n\n        // Update list\n        this.update();\n      }\n    }\n  }]);\n}(_events[\"default\"].EventEmitter);\nvar _default = exports[\"default\"] = InfiniteTree;\n\n//# sourceURL=webpack://InfiniteTree/./lib/infinite-tree.js?");

/***/ }),

/***/ "./lib/lookup-table.js":
/*!*****************************!*\
  !*** ./lib/lookup-table.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar LookupTable = /*#__PURE__*/function () {\n  function LookupTable() {\n    _classCallCheck(this, LookupTable);\n    _defineProperty(this, \"data\", {});\n  }\n  return _createClass(LookupTable, [{\n    key: \"clear\",\n    value: function clear() {\n      this.data = {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this.data[key];\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.data[key] !== undefined;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.data[key] = value;\n      return value;\n    }\n  }, {\n    key: \"unset\",\n    value: function unset(key) {\n      if (this.data[key] !== undefined) {\n        delete this.data[key];\n      }\n    }\n  }]);\n}();\nvar _default = exports[\"default\"] = LookupTable;\n\n//# sourceURL=webpack://InfiniteTree/./lib/lookup-table.js?");

/***/ }),

/***/ "./lib/remove-array-items.js":
/*!***********************************!*\
  !*** ./lib/remove-array-items.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n/**\n * Remove a range of items from an array.\n *\n * @function removeItems\n * @param {Array<*>} arr The target array.\n * @param {number} startIndex The index to begin removing from (inclusive).\n * @param {number} removeCount How many items to remove.\n */\nvar removeArrayItems = function removeArrayItems(arr, startIndex, removeCount) {\n  var length = arr.length;\n  if (startIndex >= length || removeCount <= 0 || startIndex < 0) {\n    return;\n  }\n  removeCount = startIndex + removeCount > length ? length - startIndex : removeCount;\n  var len = length - removeCount;\n  for (var i = startIndex; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n};\nvar _default = exports[\"default\"] = removeArrayItems;\n\n//# sourceURL=webpack://InfiniteTree/./lib/remove-array-items.js?");

/***/ }),

/***/ "./lib/renderer.js":
/*!*************************!*\
  !*** ./lib/renderer.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultRowRenderer = void 0;\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\"));\nvar _escapeHtml = _interopRequireDefault(__webpack_require__(/*! escape-html */ \"./node_modules/escape-html/index.js\"));\nvar _html5Tag = _interopRequireDefault(__webpack_require__(/*! html5-tag */ \"./node_modules/html5-tag/lib/index.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\n/* eslint import/prefer-default-export: 0 */\n\nvar defaultRowRenderer = exports.defaultRowRenderer = function defaultRowRenderer(node, treeOptions) {\n  var id = node.id,\n    name = node.name,\n    _node$loadOnDemand = node.loadOnDemand,\n    loadOnDemand = _node$loadOnDemand === void 0 ? false : _node$loadOnDemand,\n    children = node.children,\n    state = node.state;\n  var droppable = treeOptions.droppable;\n  var depth = state.depth,\n    open = state.open,\n    path = state.path,\n    total = state.total,\n    _state$selected = state.selected,\n    selected = _state$selected === void 0 ? false : _state$selected,\n    filtered = state.filtered;\n  var childrenLength = Object.keys(children).length;\n  var more = node.hasChildren();\n  if (filtered === false) {\n    return '';\n  }\n  var togglerContent = '';\n  if (!more && loadOnDemand) {\n    togglerContent = '';\n  }\n  if (more && open) {\n    togglerContent = '';\n  }\n  if (more && !open) {\n    togglerContent = '';\n  }\n  var toggler = (0, _html5Tag[\"default\"])('a', {\n    'class': function () {\n      if (!more && loadOnDemand) {\n        return (0, _classnames[\"default\"])(treeOptions.togglerClass, 'infinite-tree-closed');\n      }\n      if (more && open) {\n        return (0, _classnames[\"default\"])(treeOptions.togglerClass);\n      }\n      if (more && !open) {\n        return (0, _classnames[\"default\"])(treeOptions.togglerClass, 'infinite-tree-closed');\n      }\n      return '';\n    }()\n  }, togglerContent);\n  var title = (0, _html5Tag[\"default\"])('span', {\n    'class': (0, _classnames[\"default\"])('infinite-tree-title')\n  }, (0, _escapeHtml[\"default\"])(name));\n  var treeNode = (0, _html5Tag[\"default\"])('div', {\n    'class': 'infinite-tree-node',\n    'style': \"margin-left: \".concat(depth * 18, \"px\")\n  }, toggler + title);\n  return (0, _html5Tag[\"default\"])('div', {\n    'data-id': id,\n    'data-expanded': more && open,\n    'data-depth': depth,\n    'data-path': path,\n    'data-selected': selected,\n    'data-children': childrenLength,\n    'data-total': total,\n    'class': (0, _classnames[\"default\"])('infinite-tree-item', {\n      'infinite-tree-selected': selected\n    }),\n    'droppable': droppable\n  }, treeNode);\n};\n\n//# sourceURL=webpack://InfiniteTree/./lib/renderer.js?");

/***/ }),

/***/ "./lib/utilities.js":
/*!**************************!*\
  !*** ./lib/utilities.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trim = exports.get = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar trim = exports.trim = function trim(str) {\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' \\f\\n\\r\\t\\v';\n  while (chars.indexOf(str[0]) >= 0) {\n    str = str.slice(1);\n  }\n  while (chars.indexOf(str[str.length - 1]) >= 0) {\n    str = str.slice(0, -1);\n  }\n  return str;\n};\nvar get = exports.get = function () {\n  var re = new RegExp(/[\\w\\-]+|\\[[^\\]]*\\]+/g);\n  return function (object, path, defaultValue) {\n    if (!object || _typeof(object) !== 'object') {\n      return defaultValue;\n    }\n    path = '' + path;\n    var keys = path.match(re);\n    if (!keys) {\n      return defaultValue;\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      key = trim(key, ' \\f\\n\\r\\t\\v');\n      if (key[0] === '[') {\n        key = trim(key.slice(1, -1), ' \\f\\n\\r\\t\\v');\n      }\n      key = trim(key, '\\'\"');\n      if (object === undefined || object === null || _typeof(object) !== 'object') {\n        break;\n      }\n      object = object[key];\n      if (object === undefined) {\n        break;\n      }\n    }\n    return object !== undefined ? object : defaultValue;\n  };\n}();\n\n//# sourceURL=webpack://InfiniteTree/./lib/utilities.js?");

/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/classnames/index.js?");

/***/ }),

/***/ "./node_modules/element-class/index.js":
/*!*********************************************!*\
  !*** ./node_modules/element-class/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(opts) {\n  return new ElementClass(opts)\n}\n\nfunction indexOf(arr, prop) {\n  if (arr.indexOf) return arr.indexOf(prop)\n  for (var i = 0, len = arr.length; i < len; i++)\n    if (arr[i] === prop) return i\n  return -1\n}\n\nfunction ElementClass(opts) {\n  if (!(this instanceof ElementClass)) return new ElementClass(opts)\n  var self = this\n  if (!opts) opts = {}\n\n  // similar doing instanceof HTMLElement but works in IE8\n  if (opts.nodeType) opts = {el: opts}\n\n  this.opts = opts\n  this.el = opts.el || document.body\n  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)\n}\n\nElementClass.prototype.add = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return el.className = className\n  var classes = el.className.split(' ')\n  if (indexOf(classes, className) > -1) return classes\n  classes.push(className)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.remove = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return\n  var classes = el.className.split(' ')\n  var idx = indexOf(classes, className)\n  if (idx > -1) classes.splice(idx, 1)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.has = function(className) {\n  var el = this.el\n  if (!el) return\n  var classes = el.className.split(' ')\n  return indexOf(classes, className) > -1\n}\n\nElementClass.prototype.toggle = function(className) {\n  var el = this.el\n  if (!el) return\n  if (this.has(className)) this.remove(className)\n  else this.add(className)\n}\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/element-class/index.js?");

/***/ }),

/***/ "./node_modules/escape-html/index.js":
/*!*******************************************!*\
  !*** ./node_modules/escape-html/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/escape-html/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/flattree/lib/extend.js":
/*!*********************************************!*\
  !*** ./node_modules/flattree/lib/extend.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n/* eslint no-restricted-syntax: 0 */\nvar extend = function extend(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 0; index < sources.length; index++) {\n        var source = sources[index];\n        if (source !== undefined && source !== null) {\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    output[key] = source[key];\n                }\n            }\n        }\n    }\n    return output;\n};\n\nexports['default'] = extend;\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/flattree/lib/extend.js?");

/***/ }),

/***/ "./node_modules/flattree/lib/flatten.js":
/*!**********************************************!*\
  !*** ./node_modules/flattree/lib/flatten.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extend = __webpack_require__(/*! ./extend */ \"./node_modules/flattree/lib/extend.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _node = __webpack_require__(/*! ./node */ \"./node_modules/flattree/lib/node.js\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// @param {object|array} nodes The tree nodes.\n// @param {object} [options] The options object.\n// @param {boolean} [options.openAllNodes] True to open all nodes. Defaults to false.\n// @param {array} [options.openNodes] An array that contains the ids of open nodes.\n// @return {array}\n/* eslint no-console: 0 */\nvar flatten = function flatten() {\n    var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    nodes = [].concat(nodes);\n\n    var flatten = [];\n    var stack = [];\n    var pool = {\n        lastChild: {}\n    };\n\n    options.openAllNodes = !!options.openAllNodes;\n    options.openNodes = options.openNodes || [];\n    options.throwOnError = !!options.throwOnError;\n\n    {\n        // root node\n        var firstNode = nodes.length > 0 ? nodes[0] : null;\n        var parentNode = firstNode ? firstNode.parent : null;\n        if (parentNode && !(parentNode instanceof _node2['default'])) {\n            parentNode = new _node2['default'](parentNode);\n        }\n        var rootNode = parentNode || new _node2['default']({ // defaults\n            parent: null,\n            children: nodes,\n            state: {\n                depth: -1,\n                open: true, // always open\n                path: '',\n                prefixMask: '',\n                total: 0\n            }\n        });\n\n        if (rootNode === parentNode) {\n            var subtotal = rootNode.state.total || 0;\n\n            // Traversing up through its ancestors.\n            var p = rootNode;\n            while (p) {\n                var _p$state = p.state,\n                    path = _p$state.path,\n                    _p$state$total = _p$state.total,\n                    total = _p$state$total === undefined ? 0 : _p$state$total;\n\n                // Rebuild the lastChild pool.\n\n                if (p.isLastChild() && path) {\n                    pool.lastChild[path] = true;\n                }\n\n                // Subtract the number 'subtotal' from the total of the root node and all its ancestors.\n                p.state.total = total - subtotal;\n                if (p.state.total < 0) {\n                    if (options.throwOnError) {\n                        throw new Error('The node might have been corrupted: id=' + JSON.stringify(p.id) + ', state=' + JSON.stringify(p.state));\n                    } else {\n                        console && console.log('Error: The node might have been corrupted: id=%s, parent=%s, children=%s, state=%s', JSON.stringify(p.id), p.parent, p.children, JSON.stringify(p.state));\n                    }\n                }\n\n                p = p.parent;\n            }\n        }\n\n        stack.push([rootNode, rootNode.state.depth, 0]);\n    }\n\n    while (stack.length > 0) {\n        var _stack$pop = stack.pop(),\n            current = _stack$pop[0],\n            depth = _stack$pop[1],\n            index = _stack$pop[2];\n\n        var _loop = function _loop() {\n            var node = current.children[index];\n            if (!(node instanceof _node2['default'])) {\n                node = new _node2['default'](node);\n            }\n            node.parent = current;\n            node.children = node.children || [];\n\n            // Ensure parent.children[index] is equal to the current node.\n            node.parent.children[index] = node;\n\n            var path = current.state.path + '.' + index;\n            var open = node.hasChildren() && function () {\n                var openAllNodes = options.openAllNodes,\n                    openNodes = options.openNodes;\n\n                if (openAllNodes) {\n                    return true;\n                }\n                // determine from input\n                if (node.state && node.state.open) {\n                    return true;\n                }\n                // determine by node object\n                if (openNodes.indexOf(node) >= 0) {\n                    return true;\n                }\n                // determine by node id\n                if (openNodes.indexOf(node.id) >= 0) {\n                    return true;\n                }\n                return false;\n            }();\n            var prefixMask = function (prefix) {\n                var mask = '';\n                while (prefix.length > 0) {\n                    prefix = prefix.replace(/\\.\\d+$/, '');\n                    if (!prefix || pool.lastChild[prefix]) {\n                        mask = '0' + mask;\n                    } else {\n                        mask = '1' + mask;\n                    }\n                }\n                return mask;\n            }(path);\n\n            if (index === current.children.length - 1) {\n                // The node is the last child of its parent.\n                pool.lastChild[path] = true;\n            }\n\n            // This allows you to put extra information to node.state\n            node.state = (0, _extend2['default'])({}, node.state, {\n                depth: depth + 1,\n                open: open,\n                path: path,\n                prefixMask: prefixMask,\n                total: 0\n            });\n\n            var parentDidOpen = true;\n\n            {\n                // Check the open state from its ancestors.\n                var _p = node;\n                while (_p.parent !== null) {\n                    if (_p.parent.state.open === false) {\n                        parentDidOpen = false;\n                        break;\n                    }\n                    _p = _p.parent;\n                }\n            }\n\n            if (parentDidOpen) {\n                // Push the node to flatten list only if all of its parent nodes have the open state set to true.\n                flatten.push(node);\n\n                // Update the total number of visible child nodes.\n                var _p2 = node;\n                while (_p2.parent !== null) {\n                    _p2.parent.state.total++;\n                    _p2 = _p2.parent;\n                }\n            }\n\n            ++index;\n\n            if (node.hasChildren()) {\n                // Push back parent node to the stack that will be able to continue\n                // the next iteration once all the child nodes of the current node\n                // have been completely explored.\n                stack.push([current, depth, index]);\n\n                index = 0;\n                depth = depth + 1;\n                current = node;\n            }\n        };\n\n        while (index < current.children.length) {\n            _loop();\n        }\n    }\n\n    return flatten;\n};\n\nexports['default'] = flatten;\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/flattree/lib/flatten.js?");

/***/ }),

/***/ "./node_modules/flattree/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/flattree/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Node = exports.flatten = undefined;\n\nvar _flatten = __webpack_require__(/*! ./flatten */ \"./node_modules/flattree/lib/flatten.js\");\n\nvar _flatten2 = _interopRequireDefault(_flatten);\n\nvar _node = __webpack_require__(/*! ./node */ \"./node_modules/flattree/lib/node.js\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// IE8 compatibility output\nexports.flatten = _flatten2['default'];\nexports.Node = _node2['default'];\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/flattree/lib/index.js?");

/***/ }),

/***/ "./node_modules/flattree/lib/node.js":
/*!*******************************************!*\
  !*** ./node_modules/flattree/lib/node.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extend = __webpack_require__(/*! ./extend */ \"./node_modules/flattree/lib/extend.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function () {\n    function Node(node) {\n        _classCallCheck(this, Node);\n\n        this.id = null;\n        this.parent = null;\n        this.children = [];\n        this.state = {};\n\n        (0, _extend2['default'])(this, node);\n\n        this.children = this.children || [];\n    }\n    // Returns a boolean value indicating whether a node is a descendant of a given node or not.\n    // @param {object} node Specifies the node that may be contained by (a descendant of) a specified node.\n    // @return {boolean} Returns true if a node is a descendant of a specified node, otherwise false. A descendant can be a child, grandchild, great-grandchild, and so on.\n\n\n    Node.prototype.contains = function contains(node) {\n        while (node instanceof Node && node !== this) {\n            if (node.parent === this) {\n                return true;\n            }\n            node = node.parent;\n        }\n        return false;\n    };\n    // Gets a child node at the specified index.\n    // @param {number} The index of the child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getChildAt = function getChildAt(index) {\n        var node = null;\n        if (this.children.length > 0 && index >= 0 && index < this.children.length) {\n            node = this.children[index];\n        }\n        return node;\n    };\n    // Gets the child nodes.\n    // @return {array} Returns an array of objects that define the nodes.\n\n\n    Node.prototype.getChildren = function getChildren() {\n        return this.children;\n    };\n    // Gets the first child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getFirstChild = function getFirstChild() {\n        var node = null;\n        if (this.children.length > 0) {\n            node = this.children[0];\n        }\n        return node;\n    };\n    // Gets the last child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getLastChild = function getLastChild() {\n        var node = null;\n        if (this.children.length > 0) {\n            node = this.children[this.children.length - 1];\n        }\n        return node;\n    };\n    // Gets the next sibling node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getNextSibling = function getNextSibling() {\n        var node = null;\n        if (this.parent) {\n            var index = this.parent.children.indexOf(this);\n            if (index >= 0 && index < this.parent.children.length - 1) {\n                node = this.parent.children[index + 1];\n            }\n        }\n        return node;\n    };\n    // Gets the parent node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getParent = function getParent() {\n        return this.parent;\n    };\n    // Gets the previous sibling node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getPreviousSibling = function getPreviousSibling() {\n        var node = null;\n        if (this.parent) {\n            var index = this.parent.children.indexOf(this);\n            if (index > 0 && index < this.parent.children.length) {\n                node = this.parent.children[index - 1];\n            }\n        }\n        return node;\n    };\n    // Checks whether this node has children.\n    // @return {boolean} Returns true if the node has children, false otherwise.\n\n\n    Node.prototype.hasChildren = function hasChildren() {\n        return this.children.length > 0;\n    };\n    // Checks whether this node is the last child of its parent.\n    // @return {boolean} Returns true if the node is the last child of its parent, false otherwise.\n\n\n    Node.prototype.isLastChild = function isLastChild() {\n        var hasNextSibling = this.getNextSibling();\n        return !hasNextSibling;\n    };\n\n    return Node;\n}();\n\nexports['default'] = Node;\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/flattree/lib/node.js?");

/***/ }),

/***/ "./node_modules/html5-tag/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html5-tag/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _escapeHtml = __webpack_require__(/*! escape-html */ \"./node_modules/escape-html/index.js\");\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// https://www.w3.org/TR/html5/syntax.html#void-elements\n// Void elements only have a start tag; end tags must not be specified for void elements.\nvar voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\n// @param {string} [tag] The tag name. Defaults to 'div'.\n// @param {object} attrs HTML attributes.\n// @param {string} [text] The content string.\nmodule.exports = function (tag, attrs, text) {\n    if ((typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) === 'object') {\n        text = attrs;\n        attrs = tag;\n        tag = 'div';\n    }\n\n    var voidElement = voidElements.indexOf(('' + tag).toLowerCase()) >= 0;\n    var html = '<' + tag;\n\n    attrs = _extends({}, attrs);\n    Object.keys(attrs).forEach(function (name) {\n        var value = attrs[name];\n        if (typeof value === 'string') {\n            value = (0, _escapeHtml2.default)('' + value);\n            html += ' ' + name + '=\"' + value + '\"';\n        } else if (!!value) {\n            html += ' ' + name;\n        }\n    });\n\n    if (voidElement) {\n        html += '>';\n    } else if (text !== undefined) {\n        html += '>' + text + '</' + tag + '>';\n    } else {\n        html += '/>';\n    }\n\n    return html;\n};\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/html5-tag/lib/index.js?");

/***/ }),

/***/ "./node_modules/is-dom/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-dom/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! is-object */ \"./node_modules/is-object/index.js\")\nvar isWindow = __webpack_require__(/*! is-window */ \"./node_modules/is-window/index.js\")\n\nfunction isNode (val) {\n  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {\n    return false\n  }\n\n  return typeof val.nodeType === 'number' &&\n    typeof val.nodeName === 'string'\n}\n\nmodule.exports = isNode\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/is-dom/index.js?");

/***/ }),

/***/ "./node_modules/is-object/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-object/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isObject(x) {\n\treturn typeof x === 'object' && x !== null;\n};\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/is-object/index.js?");

/***/ }),

/***/ "./node_modules/is-window/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-window/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (obj) {\n\n  if (obj == null) {\n    return false;\n  }\n\n  var o = Object(obj);\n\n  return o === o.window;\n};\n\n\n//# sourceURL=webpack://InfiniteTree/./node_modules/is-window/index.js?");

/***/ })

/******/ });
});