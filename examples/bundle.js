!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(module,exports,__webpack_require__){eval('\'use strict\';\n\nvar InfiniteTree = __webpack_require__(1);\n\nvar data = [];\nvar source = \'{"id":"<root>","label":"<root>","children":[{"id":"alpha","label":"Alpha"},{"id":"bravo","label":"Bravo","children":[{"id":"charlie","label":"Charlie","children":[{"id":"delta","label":"Delta","children":[{"id":"echo","label":"Echo"},{"id":"foxtrot","label":"Foxtrot"}]},{"id":"golf","label":"Golf"}]},{"id":"hotel","label":"Hotel","children":[{"id":"india","label":"India","children":[{"id":"juliet","label":"Juliet"}]}]},{"id":"kilo","label":"Kilo"}]}]}\';\n\nfor (var i = 0; i < 1000; ++i) {\n    data.push(JSON.parse(source.replace(/"(id|label)":"([^"]*)"/g, \'"$1": "$2.\' + i + \'"\')));\n}\n\nvar tree = new InfiniteTree({\n    autoOpen: true,\n    el: document.querySelector(\'#tree\')\n\n});\n\n// Customize your row renderer\n/*\nrowRenderer: (node) => {\n    return \'<div>\' + node.label + \'</div>\'\n}\n*/\ntree.on(\'tree.open\', function (node) {\n    console.log(\'tree.open\', node);\n});\ntree.on(\'tree.close\', function (node) {\n    console.log(\'tree.close\', node);\n});\ntree.on(\'tree.select\', function (node) {\n    console.log(\'tree.select\', node);\n});\n\ntree.loadData(data);\n\nwindow.tree = tree;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./index.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(2);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _clusterize = __webpack_require__(3);\n\nvar _clusterize2 = _interopRequireDefault(_clusterize);\n\nvar _flattree = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(5);\n\nvar _utils = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar extend = function extend(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    sources.forEach(function (source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n    });\n\n    return target;\n};\n\nvar addEventListener = function addEventListener(target, type, listener) {\n    if (target.attachEvent) {\n        return target.attachEvent('on' + type, listener);\n    } else {\n        return target.addEventListener(type, listener, false);\n    }\n};\n\nvar removeEventListener = function removeEventListener(target, type, listener) {\n    if (target.detachEvent) {\n        return target.detachEvent('on' + type, listener);\n    } else {\n        return target.removeEventListener(type, listener, false);\n    }\n};\n\nvar stopPropagation = function stopPropagation(evt) {\n    if (typeof evt.stopPropagation !== 'undefined') {\n        evt.stopPropagation();\n    } else {\n        evt.cancelBubble = true;\n    }\n};\n\nvar generateRows = function generateRows() {\n    var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n    var rowRenderer = arguments.length <= 1 || arguments[1] === undefined ? _renderer.defaultRowRenderer : arguments[1];\n\n    return nodes.map(function (node) {\n        return rowRenderer(node);\n    });\n};\n\nvar InfiniteTree = function (_events$EventEmitter) {\n    _inherits(InfiniteTree, _events$EventEmitter);\n\n    function InfiniteTree() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, InfiniteTree);\n\n        // Assign options\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(InfiniteTree).call(this));\n\n        _this.options = {\n            autoOpen: false,\n            el: null,\n            rowRenderer: _renderer.defaultRowRenderer\n        };\n        _this.state = {\n            openNodes: [],\n            selectedNode: null\n        };\n        _this.clusterize = null;\n        _this.nodebucket = {};\n        _this.nodes = [];\n        _this.rows = [];\n        _this.contentElement = null;\n\n        _this.contentListener = function (evt) {\n            var target = evt.target;\n            var currentTarget = evt.currentTarget;\n\n\n            stopPropagation(evt);\n\n            if (target !== currentTarget) {\n                var itemTarget = target;\n\n                while (itemTarget && itemTarget.parentElement !== currentTarget) {\n                    itemTarget = itemTarget.parentElement;\n                }\n\n                var id = itemTarget.getAttribute('aria-id');\n                var node = _this.getNodeById(id);\n\n                // Click on the toggler to open/close a tree node\n                if (target.className.indexOf('tree-toggler') >= 0) {\n                    if (_this.state.openNodes.indexOf(node) >= 0) {\n                        // Close node\n                        _this.closeNode(node);\n                    } else {\n                        _this.openNode(node);\n                    }\n                } else {\n                    _this.selectNode(node);\n                }\n            }\n        };\n\n        _this.options = extend({}, _this.options, options);\n\n        if (!_this.options.el) {\n            console.error('Failed to initialize infinite-tree: el is not specified.', options);\n            return _possibleConstructorReturn(_this);\n        }\n\n        _this.create();\n\n        // Load tree data if it's provided\n        if (options.data) {\n            _this.loadData(options.data);\n        }\n        return _this;\n    }\n\n    _createClass(InfiniteTree, [{\n        key: 'create',\n        value: function create() {\n            var infiniteTree = document.createElement('div');\n            infiniteTree.className = (0, _utils.classNames)('infinite-tree');\n            var infiniteTreeScroll = document.createElement('div');\n            infiniteTreeScroll.className = (0, _utils.classNames)('infinite-tree-scroll');\n            var infiniteTreeContent = document.createElement('div');\n            infiniteTreeContent.className = (0, _utils.classNames)('infinite-tree-content');\n\n            infiniteTreeScroll.appendChild(infiniteTreeContent);\n            infiniteTree.appendChild(infiniteTreeScroll);\n            this.options.el.appendChild(infiniteTree);\n\n            this.clusterize = new _clusterize2.default({\n                tag: 'div',\n                rows: [],\n                scrollElem: infiniteTreeScroll,\n                contentElem: infiniteTreeContent,\n                no_data_class: 'infinite-tree-no-data'\n            });\n\n            this.contentElement = infiniteTreeContent;\n            addEventListener(this.contentElement, 'click', this.contentListener);\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            removeEventListener(this.contentElement, 'click', this.contentListener);\n\n            if (this.clusterize) {\n                this.clusterize.clear();\n                this.clusterize = null;\n            }\n\n            this.nodes = [];\n            this.rows = [];\n            this.state.openNodes = [];\n            this.state.selectedNode = null;\n\n            // Remove all child nodes\n            while (this.contentElement.firstChild) {\n                this.contentElement.removeChild(this.contentElement.firstChild);\n            }\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            this.clusterize.clear();\n            this.nodes = [];\n            this.rows = [];\n            this.state.openNodes = [];\n            this.state.selectedNode = null;\n        }\n        // Updates list with new data\n\n    }, {\n        key: 'update',\n        value: function update() {\n            this.clusterize.update(this.rows);\n        }\n        // Add a new node after this existing node.\n        // @param {object} newNode\n        // @param {object} node\n\n    }, {\n        key: 'addNodeAfter',\n        value: function addNodeAfter(newNode, node) {}\n        // TODO\n\n        // Add a new node before this existing node.\n        // @param {object} newNode\n        // @param {object} node\n\n    }, {\n        key: 'addNodeBefore',\n        value: function addNodeBefore(newNode, node) {}\n        // TODO\n\n        // Add a new node as parent of this existing node.\n        // @param {object} newNode\n        // @param {object} node\n\n    }, {\n        key: 'addParentNode',\n        value: function addParentNode(newNode, node) {}\n        // TODO\n\n        // Add a node to this parent node. If parentNode is empty, then the new node becomes a root node.\n        // @param {object} newNode The new node\n        // @param {object} parentNode The parent node\n\n    }, {\n        key: 'appendNode',\n        value: function appendNode(newNode, parentNode) {}\n        // TODO\n\n        // Close this node. The node must have child nodes.\n        // @param {object} node\n\n    }, {\n        key: 'closeNode',\n        value: function closeNode(node) {\n            var rowRenderer = this.options.rowRenderer;\n\n            var nodeIndex = this.nodes.indexOf(node);\n            if (nodeIndex < 0) {\n                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));\n            }\n\n            // Check if the closeNode action can be performed\n            if (this.state.openNodes.indexOf(node) < 0) {\n                return false;\n            }\n\n            // Keep selected node unchanged if \"node\" is equal to \"this.state.selectedNode\"\n            if (this.state.selectedNode && this.state.selectedNode !== node) {\n                // Action:\n                //   close \"node.0.0\"\n                //\n                // Tree:\n                // [0] - node.0\n                // [1]  - node.0.0      => next selected node (index=1, total=2)\n                // [2]      node.0.0.0  => last selected node (index=2, total=0)\n                // [3]      node.0.0.1\n                // [4]    node.0.1\n                var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n                var rangeFrom = nodeIndex + 1;\n                var rangeTo = nodeIndex + node.state.total;\n\n                if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n                    this.selectNode(node);\n                }\n            }\n\n            node.state.open = false; // Set node.state.open to false\n            var openNodes = this.state.openNodes.filter(function (node) {\n                return node.state.more && node.state.open;\n            });\n            this.state.openNodes = openNodes;\n\n            var deleteCount = node.state.total;\n\n            {\n                // Traversing up through ancestors to subtract node.state.total\n                var p = node;\n                while (p) {\n                    p.state.total = p.state.total - deleteCount;\n                    p = p.parent;\n                }\n            }\n\n            // Remove elements from an array\n            this.nodes.splice(nodeIndex + 1, deleteCount);\n            this.rows.splice(nodeIndex + 1, deleteCount);\n            this.rows[nodeIndex] = rowRenderer(node);\n\n            this.emit('tree.close', node);\n\n            // Updates list with new data\n            this.update();\n\n            return true;\n        }\n        // Get a tree node by the unique node id. This assumes that you have given the nodes in the data a unique id.\n        // @param {string|number} id The unique node id. A null value will be returned if node.id not matched.\n\n    }, {\n        key: 'getNodeById',\n        value: function getNodeById(id) {\n            var node = (this.nodebucket[id] || [])[0];\n            return node !== undefined ? node : null;\n        }\n        // Get the selected node. Returns the row data or null.\n\n    }, {\n        key: 'getSelectedNode',\n        value: function getSelectedNode() {\n            return this.state.selectedNode;\n        }\n        // Get the state of the tree.\n        // @return {object} Returns an object that contains the ids of open nodes and selected nodes\n\n    }, {\n        key: 'getState',\n        value: function getState() {}\n        // TODO\n\n        // Get the root node of the tree.\n\n    }, {\n        key: 'getTree',\n        value: function getTree() {\n            var tree = this.nodes.length > 0 ? this.nodes[0] : null;\n            while (tree && tree.parent !== null) {\n                tree = tree.parent;\n            }\n            return tree;\n        }\n        // Load data in the tree.\n        // @param {object|array} data The data is a node object or array of nodes\n\n    }, {\n        key: 'loadData',\n        value: function loadData() {\n            var _this2 = this;\n\n            var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n            var _options = this.options;\n            var autoOpen = _options.autoOpen;\n            var rowRenderer = _options.rowRenderer;\n\n\n            this.nodes = (0, _flattree.flatten)(data, { openAllNodes: autoOpen });\n\n            // Construct node bucket\n            this.nodebucket = {};\n            this.nodes.forEach(function (node) {\n                if (node.id !== undefined) {\n                    var nodebucket = _this2.nodebucket[node.id];\n                    _this2.nodebucket[node.id] = nodebucket ? nodebucket.concat(node) : [node];\n                }\n            });\n\n            var openNodes = this.nodes.filter(function (node) {\n                return node.state.more && node.state.open;\n            });\n            this.state.openNodes = openNodes;\n            this.state.selectedNode = null;\n\n            this.rows = this.nodes.map(function (node) {\n                return rowRenderer(node);\n            });\n\n            // Updates list with new data\n            this.update();\n        }\n        // Open this node. The node must have child nodes.\n        // @param {object} node\n\n    }, {\n        key: 'openNode',\n        value: function openNode(node) {\n            var rowRenderer = this.options.rowRenderer;\n\n            var nodeIndex = this.nodes.indexOf(node);\n            if (nodeIndex < 0) {\n                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));\n            }\n\n            // Check if the openNode action can be performed\n            if (this.state.openNodes.indexOf(node) >= 0) {\n                return false;\n            }\n\n            node.state.open = true; // Set node.state.open to true\n            var openNodes = [node].concat(this.state.openNodes); // the most recently used items first\n            this.state.openNodes = openNodes;\n\n            var nodes = (0, _flattree.flatten)(node.children, { openNodes: this.state.openNodes });\n            var rows = generateRows(nodes, rowRenderer);\n\n            // Insert an array inside another array\n            this.nodes.splice.apply(this.nodes, [nodeIndex + 1, 0].concat(nodes));\n            this.rows.splice.apply(this.rows, [nodeIndex + 1, 0].concat(rows));\n            this.rows[nodeIndex] = generateRows([node], rowRenderer)[0];\n\n            this.emit('tree.open', node);\n\n            // Updates list with new data\n            this.update();\n\n            return true;\n        }\n        // Remove node from the tree\n        // @param {object} node\n\n    }, {\n        key: 'removeNode',\n        value: function removeNode(node) {}\n        // TODO\n\n        // Scroll to this node.\n        // @param {object} node\n\n    }, {\n        key: 'scrollToNode',\n        value: function scrollToNode(node) {}\n        // TODO\n\n        // Select this node. You can deselect the current node by calling selectNode(null) or selectNode().\n        // @param {object} node\n\n    }, {\n        key: 'selectNode',\n        value: function selectNode() {\n            var node = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n            var rowRenderer = this.options.rowRenderer;\n\n\n            if (node === null) {\n                // Deselect the current node\n                if (this.state.selectedNode) {\n                    var selectedNode = this.state.selectedNode;\n                    var selectedIndex = this.nodes.indexOf(selectedNode);\n                    selectedNode.state.selected = false;\n                    this.rows[selectedIndex] = rowRenderer(selectedNode);\n\n                    this.state.selectedNode = null;\n                    this.emit('tree.select', null);\n\n                    // Updates list with new data\n                    this.update();\n\n                    return true;\n                }\n\n                return false;\n            }\n\n            var nodeIndex = this.nodes.indexOf(node);\n            if (nodeIndex < 0) {\n                throw new Error('Invalid node specified: node.id=' + JSON.stringify(node.id));\n            }\n\n            // Select this node\n            if (this.state.selectedNode !== node) {\n                node.state.selected = true;\n                this.rows[nodeIndex] = rowRenderer(node);\n            }\n\n            // Deselect the current node\n            if (this.state.selectedNode) {\n                var _selectedNode = this.state.selectedNode;\n                var _selectedIndex = this.nodes.indexOf(_selectedNode);\n                _selectedNode.state.selected = false;\n                this.rows[_selectedIndex] = rowRenderer(_selectedNode);\n            }\n\n            if (this.state.selectedNode !== node) {\n                this.state.selectedNode = node;\n                this.emit('tree.select', node);\n            } else {\n                this.state.selectedNode = null;\n                this.emit('tree.select', null);\n            }\n\n            // Updates list with new data\n            this.update();\n\n            return true;\n        }\n        // Set the state of the tree. See getState for more information.\n        // @param {object} state The state object\n        // @param {string} [state.openNodes] The ids of open nodes\n        // @param {string} [state.selectedNode] The id of selected node\n\n    }, {\n        key: 'setState',\n        value: function setState() {\n            var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n        }\n        // TODO\n\n        // Open or close this node.\n\n    }, {\n        key: 'toggle',\n        value: function toggle(node) {}\n        // TODO\n\n        // Get the tree data as string.\n\n    }, {\n        key: 'toString',\n        value: function toString() {}\n        // TODO\n\n        // Update the title of a node. You can also update the data.\n        // @param {object} node\n        // @param {object} data The data object\n        // @param {object} [data.label] The title of a node\n\n    }, {\n        key: 'updateNode',\n        value: function updateNode(node, data) {\n            // TODO\n        }\n    }]);\n\n    return InfiniteTree;\n}(_events2.default.EventEmitter);\n\nmodule.exports = InfiniteTree;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/index.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/index.js?")},function(module,exports){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/events/events.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/events/events.js?")},function(module,exports,__webpack_require__){eval("/*! Clusterize.js - v0.16.0 - 2016-03-12\r\n* http://NeXTs.github.com/Clusterize.js/\r\n* Copyright (c) 2015 Denis Lukov; Licensed GPLv3 */\r\n\r\n;(function(name, definition) {\r\n    if (true) module.exports = definition();\r\n    else if (typeof define == 'function' && typeof define.amd == 'object') define(definition);\r\n    else this[name] = definition();\r\n}('Clusterize', function() {\r\n  \"use strict\"\r\n\r\n  // detect ie9 and lower\r\n  // https://gist.github.com/padolsey/527683#comment-786682\r\n  var ie = (function(){\r\n    for( var v = 3,\r\n             el = document.createElement('b'),\r\n             all = el.all || [];\r\n         el.innerHTML = '<!--[if gt IE ' + (++v) + ']><i><![endif]-->',\r\n         all[0];\r\n       ){}\r\n    return v > 4 ? v : document.documentMode;\r\n  }()),\r\n  is_mac = navigator.platform.toLowerCase().indexOf('mac') + 1;\r\n  var Clusterize = function(data) {\r\n    if( ! (this instanceof Clusterize))\r\n      return new Clusterize(data);\r\n    var self = this;\r\n\r\n    var defaults = {\r\n      item_height: 0,\r\n      block_height: 0,\r\n      rows_in_block: 50,\r\n      rows_in_cluster: 0,\r\n      cluster_height: 0,\r\n      blocks_in_cluster: 4,\r\n      tag: null,\r\n      content_tag: null,\r\n      show_no_data_row: true,\r\n      no_data_class: 'clusterize-no-data',\r\n      no_data_text: 'No data',\r\n      keep_parity: true,\r\n      callbacks: {},\r\n      scroll_top: 0\r\n    }\r\n\r\n    // public parameters\r\n    self.options = {};\r\n    var options = ['rows_in_block', 'blocks_in_cluster', 'show_no_data_row', 'no_data_class', 'no_data_text', 'keep_parity', 'tag', 'callbacks'];\r\n    for(var i = 0, option; option = options[i]; i++) {\r\n      self.options[option] = typeof data[option] != 'undefined' && data[option] != null\r\n        ? data[option]\r\n        : defaults[option];\r\n    }\r\n\r\n    var elems = ['scroll', 'content'];\r\n    for(var i = 0, elem; elem = elems[i]; i++) {\r\n      self[elem + '_elem'] = data[elem + 'Id']\r\n        ? document.getElementById(data[elem + 'Id'])\r\n        : data[elem + 'Elem'];\r\n      if( ! self[elem + '_elem'])\r\n        throw new Error(\"Error! Could not find \" + elem + \" element\");\r\n    }\r\n\r\n    // tabindex forces the browser to keep focus on the scrolling list, fixes #11\r\n    if( ! self.content_elem.hasAttribute('tabindex'))\r\n      self.content_elem.setAttribute('tabindex', 0);\r\n\r\n    // private parameters\r\n    var rows = isArray(data.rows)\r\n        ? data.rows\r\n        : self.fetchMarkup(),\r\n      cache = {data: '', bottom: 0},\r\n      scroll_top = self.scroll_elem.scrollTop;\r\n\r\n    // get row height\r\n    self.exploreEnvironment(rows);\r\n\r\n    // append initial data\r\n    self.insertToDOM(rows, cache);\r\n\r\n    // restore the scroll position\r\n    self.scroll_elem.scrollTop = scroll_top;\r\n\r\n    // adding scroll handler\r\n    var last_cluster = false,\r\n    scroll_debounce = 0,\r\n    pointer_events_set = false,\r\n    scrollEv = function() {\r\n      // fixes scrolling issue on Mac #3\r\n      if (is_mac) {\r\n          if( ! pointer_events_set) self.content_elem.style.pointerEvents = 'none';\r\n          pointer_events_set = true;\r\n          clearTimeout(scroll_debounce);\r\n          scroll_debounce = setTimeout(function () {\r\n              self.content_elem.style.pointerEvents = 'auto';\r\n              pointer_events_set = false;\r\n          }, 50);\r\n      }\r\n      if (last_cluster != (last_cluster = self.getClusterNum()))\r\n        self.insertToDOM(rows, cache);\r\n      if (self.options.callbacks.scrollingProgress)\r\n        self.options.callbacks.scrollingProgress(self.getScrollProgress());\r\n    },\r\n    resize_debounce = 0,\r\n    resizeEv = function() {\r\n      clearTimeout(resize_debounce);\r\n      resize_debounce = setTimeout(self.refresh, 100);\r\n    }\r\n    on('scroll', self.scroll_elem, scrollEv);\r\n    on('resize', window, resizeEv);\r\n\r\n    // public methods\r\n    self.destroy = function(clean) {\r\n      off('scroll', self.scroll_elem, scrollEv);\r\n      off('resize', window, resizeEv);\r\n      self.html((clean ? self.generateEmptyRow() : rows).join(''));\r\n    }\r\n    self.refresh = function() {\r\n      self.getRowsHeight(rows) && self.update(rows);\r\n    }\r\n    self.update = function(new_rows) {\r\n      rows = isArray(new_rows)\r\n        ? new_rows\r\n        : [];\r\n      var scroll_top = self.scroll_elem.scrollTop;\r\n      // fixes #39\r\n      if(rows.length * self.options.item_height < scroll_top) {\r\n        self.scroll_elem.scrollTop = 0;\r\n        last_cluster = 0;\r\n      }\r\n      self.insertToDOM(rows, cache);\r\n      self.scroll_elem.scrollTop = scroll_top;\r\n    }\r\n    self.clear = function() {\r\n      self.update([]);\r\n    }\r\n    self.getRowsAmount = function() {\r\n      return rows.length;\r\n    }\r\n    self.getScrollProgress = function() {\r\n      return this.options.scroll_top / (rows.length * this.options.item_height) * 100 || 0;\r\n    }\r\n\r\n    var add = function(where, _new_rows) {\r\n      var new_rows = isArray(_new_rows)\r\n        ? _new_rows\r\n        : [];\r\n      if( ! new_rows.length) return;\r\n      rows = where == 'append'\r\n        ? rows.concat(new_rows)\r\n        : new_rows.concat(rows);\r\n      self.insertToDOM(rows, cache);\r\n    }\r\n    self.append = function(rows) {\r\n      add('append', rows);\r\n    }\r\n    self.prepend = function(rows) {\r\n      add('prepend', rows);\r\n    }\r\n  }\r\n\r\n  Clusterize.prototype = {\r\n    constructor: Clusterize,\r\n    // fetch existing markup\r\n    fetchMarkup: function() {\r\n      var rows = [], rows_nodes = this.getChildNodes(this.content_elem);\r\n      while (rows_nodes.length) {\r\n        rows.push(rows_nodes.shift().outerHTML);\r\n      }\r\n      return rows;\r\n    },\r\n    // get tag name, content tag name, tag height, calc cluster height\r\n    exploreEnvironment: function(rows) {\r\n      var opts = this.options;\r\n      opts.content_tag = this.content_elem.tagName.toLowerCase();\r\n      if( ! rows.length) return;\r\n      if(ie && ie <= 9 && ! opts.tag) opts.tag = rows[0].match(/<([^>\\s/]*)/)[1].toLowerCase();\r\n      if(this.content_elem.children.length <= 1) this.html(rows[0] + rows[0] + rows[0]);\r\n      if( ! opts.tag) opts.tag = this.content_elem.children[0].tagName.toLowerCase();\r\n      this.getRowsHeight(rows);\r\n    },\r\n    getRowsHeight: function(rows) {\r\n      var opts = this.options,\r\n        prev_item_height = opts.item_height;\r\n      opts.cluster_height = 0\r\n      if( ! rows.length) return;\r\n      var nodes = this.content_elem.children;\r\n      opts.item_height = nodes[Math.floor(nodes.length / 2)].offsetHeight;\r\n      // consider table's border-spacing\r\n      if(opts.tag == 'tr' && getStyle('borderCollapse', this.content_elem) != 'collapse')\r\n        opts.item_height += parseInt(getStyle('borderSpacing', this.content_elem)) || 0;\r\n      opts.block_height = opts.item_height * opts.rows_in_block;\r\n      opts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;\r\n      opts.cluster_height = opts.blocks_in_cluster * opts.block_height;\r\n      return prev_item_height != opts.item_height;\r\n    },\r\n    // get current cluster number\r\n    getClusterNum: function () {\r\n      this.options.scroll_top = this.scroll_elem.scrollTop;\r\n      return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;\r\n    },\r\n    // generate empty row if no data provided\r\n    generateEmptyRow: function() {\r\n      var opts = this.options;\r\n      if( ! opts.tag || ! opts.show_no_data_row) return [];\r\n      var empty_row = document.createElement(opts.tag),\r\n        no_data_content = document.createTextNode(opts.no_data_text), td;\r\n      empty_row.className = opts.no_data_class;\r\n      if(opts.tag == 'tr') {\r\n        td = document.createElement('td');\r\n        td.appendChild(no_data_content);\r\n      }\r\n      empty_row.appendChild(td || no_data_content);\r\n      return [empty_row.outerHTML];\r\n    },\r\n    // generate cluster for current scroll position\r\n    generate: function (rows, cluster_num) {\r\n      var opts = this.options,\r\n        rows_len = rows.length;\r\n      if (rows_len < opts.rows_in_block) {\r\n        return {\r\n          top_offset: 0,\r\n          bottom_offset: 0,\r\n          rows_above: 0,\r\n          rows: rows_len ? rows : this.generateEmptyRow()\r\n        }\r\n      }\r\n      if( ! opts.cluster_height) {\r\n        this.exploreEnvironment(rows);\r\n      }\r\n      var items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),\r\n        items_end = items_start + opts.rows_in_cluster,\r\n        top_offset = Math.max(items_start * opts.item_height, 0),\r\n        bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0),\r\n        this_cluster_rows = [],\r\n        rows_above = items_start;\r\n      if(top_offset < 1) {\r\n        rows_above++;\r\n      }\r\n      for (var i = items_start; i < items_end; i++) {\r\n        rows[i] && this_cluster_rows.push(rows[i]);\r\n      }\r\n      return {\r\n        top_offset: top_offset,\r\n        bottom_offset: bottom_offset,\r\n        rows_above: rows_above,\r\n        rows: this_cluster_rows\r\n      }\r\n    },\r\n    renderExtraTag: function(class_name, height) {\r\n      var tag = document.createElement(this.options.tag),\r\n        clusterize_prefix = 'clusterize-';\r\n      tag.className = [clusterize_prefix + 'extra-row', clusterize_prefix + class_name].join(' ');\r\n      height && (tag.style.height = height + 'px');\r\n      return tag.outerHTML;\r\n    },\r\n    // if necessary verify data changed and insert to DOM\r\n    insertToDOM: function(rows, cache) {\r\n      var data = this.generate(rows, this.getClusterNum()),\r\n        this_cluster_rows = data.rows.join(''),\r\n        this_cluster_content_changed = this.checkChanges('data', this_cluster_rows, cache),\r\n        only_bottom_offset_changed = this.checkChanges('bottom', data.bottom_offset, cache),\r\n        callbacks = this.options.callbacks,\r\n        layout = [];\r\n\r\n      if(this_cluster_content_changed) {\r\n        if(data.top_offset) {\r\n          this.options.keep_parity && layout.push(this.renderExtraTag('keep-parity'));\r\n          layout.push(this.renderExtraTag('top-space', data.top_offset));\r\n        }\r\n        layout.push(this_cluster_rows);\r\n        data.bottom_offset && layout.push(this.renderExtraTag('bottom-space', data.bottom_offset));\r\n        callbacks.clusterWillChange && callbacks.clusterWillChange();\r\n        this.html(layout.join(''));\r\n        this.options.content_tag == 'ol' && this.content_elem.setAttribute('start', data.rows_above);\r\n        callbacks.clusterChanged && callbacks.clusterChanged();\r\n      } else if(only_bottom_offset_changed) {\r\n        this.content_elem.lastChild.style.height = data.bottom_offset + 'px';\r\n      }\r\n    },\r\n    // unfortunately ie <= 9 does not allow to use innerHTML for table elements, so make a workaround\r\n    html: function(data) {\r\n      var content_elem = this.content_elem;\r\n      if(ie && ie <= 9 && this.options.tag == 'tr') {\r\n        var div = document.createElement('div'), last;\r\n        div.innerHTML = '<table><tbody>' + data + '</tbody></table>';\r\n        while((last = content_elem.lastChild)) {\r\n          content_elem.removeChild(last);\r\n        }\r\n        var rows_nodes = this.getChildNodes(div.firstChild.firstChild);\r\n        while (rows_nodes.length) {\r\n          content_elem.appendChild(rows_nodes.shift());\r\n        }\r\n      } else {\r\n        content_elem.innerHTML = data;\r\n      }\r\n    },\r\n    getChildNodes: function(tag) {\r\n        var child_nodes = tag.children, nodes = [];\r\n        for (var i = 0, ii = child_nodes.length; i < ii; i++) {\r\n            nodes.push(child_nodes[i]);\r\n        }\r\n        return nodes;\r\n    },\r\n    checkChanges: function(type, value, cache) {\r\n      var changed = value != cache[type];\r\n      cache[type] = value;\r\n      return changed;\r\n    }\r\n  }\r\n\r\n  // support functions\r\n  function on(evt, element, fnc) {\r\n    return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent(\"on\" + evt, fnc);\r\n  }\r\n  function off(evt, element, fnc) {\r\n    return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent(\"on\" + evt, fnc);\r\n  }\r\n  function isArray(arr) {\r\n    return Object.prototype.toString.call(arr) === '[object Array]';\r\n  }\r\n  function getStyle(prop, elem) {\r\n    return window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop];\r\n  }\r\n\r\n  return Clusterize;\r\n}));\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/clusterize.js/clusterize.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/clusterize.js/clusterize.js?");
},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar extend = function extend(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    sources.forEach(function (source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n    });\n\n    return target;\n};\n\n// @param {object|array} nodes The tree nodes\n// @param {object} [options] The options object\n// @param {boolean} [options.openAllNodes] True to open all nodes. Defaults to false.\n// @param {array} [options.openNodes] An array that contains the ids of open nodes\n// @return {array}\nvar flatten = function flatten() {\n    var nodes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    nodes = [].concat(nodes);\n\n    var flatten = [];\n    var stack = [];\n    var pool = {\n        lastChild: {}\n    };\n\n    options.openAllNodes = !!options.openAllNodes;\n    options.openNodes = options.openNodes || [];\n    options.throwOnError = !!options.throwOnError;\n\n    {\n        // root node\n        var firstNode = nodes.length > 0 ? nodes[0] : null;\n        var parent = firstNode ? firstNode.parent : null;\n        var index = 0;\n        var root = parent || { // defaults\n            label: '',\n            parent: null,\n            children: nodes,\n            state: {\n                depth: -1,\n                path: '',\n                total: 0\n            }\n        };\n\n        if (root === parent) {\n            var subtotal = root.state.total || 0;\n\n            // Traversing up through its ancestors\n            var p = root;\n            while (p) {\n                var _p$state = p.state;\n                var path = _p$state.path;\n                var lastChild = _p$state.lastChild;\n                var _p$state$total = _p$state.total;\n                var total = _p$state$total === undefined ? 0 : _p$state$total;\n\n                // Rebuild the lastChild pool\n\n                if (path && lastChild) {\n                    pool.lastChild[path] = true;\n                }\n\n                // Subtract the number 'subtotal' from the total of the root node and all its ancestors\n                p.state.total = total - subtotal;\n                if (p.state.total < 0) {\n                    if (options.throwOnError) {\n                        throw new Error('The node might have been corrupted: id=' + JSON.stringify(p.id) + ', state=' + JSON.stringify(p.state));\n                    } else {\n                        console && console.log('Error: The node might have been corrupted: id=%s, label=%s, parent=%s, children=%s, state=%s', JSON.stringify(p.id), JSON.stringify(p.label), p.parent, p.children, JSON.stringify(p.state));\n                    }\n                }\n\n                p = p.parent;\n            }\n        }\n\n        stack.push([root, root.state.depth, index]);\n    }\n\n    while (stack.length > 0) {\n        var _stack$pop = stack.pop();\n\n        var _stack$pop2 = _slicedToArray(_stack$pop, 3);\n\n        var current = _stack$pop2[0];\n        var depth = _stack$pop2[1];\n        var _index = _stack$pop2[2];\n\n        var _loop = function _loop() {\n            var node = current.children[_index];\n            node.parent = current;\n            node.children = node.children || [];\n\n            var path = current.state.path + '.' + _index;\n            var more = Object.keys(node.children).length > 0;\n            var open = more && function () {\n                var openAllNodes = options.openAllNodes;\n                var openNodes = options.openNodes;\n\n                if (openAllNodes) {\n                    return true;\n                }\n                // determine by node object\n                if (openNodes.indexOf(node) >= 0) {\n                    return true;\n                }\n                // determine by node id\n                if (openNodes.indexOf(node.id) >= 0) {\n                    return true;\n                }\n                return false;\n            }();\n            var lastChild = _index === current.children.length - 1;\n            var prefixMask = function (prefix) {\n                var mask = '';\n                while (prefix.length > 0) {\n                    prefix = prefix.replace(/\\.\\d+$/, '');\n                    if (!prefix || pool.lastChild[prefix]) {\n                        mask = '0' + mask;\n                    } else {\n                        mask = '1' + mask;\n                    }\n                }\n                return mask;\n            }(path);\n\n            if (lastChild) {\n                pool.lastChild[path] = true;\n            }\n\n            // This allows you to put extra information to node.state\n            node.state = extend({}, node.state, {\n                depth: depth + 1,\n                lastChild: lastChild,\n                more: more,\n                open: open,\n                path: path,\n                prefixMask: prefixMask,\n                total: 0\n            });\n\n            {\n                // Traversing up through its ancestors and update the total number of child nodes\n                var _p = node;\n                while (_p.parent !== null) {\n                    _p.parent.state.total++;\n                    _p = _p.parent;\n                }\n            }\n\n            flatten.push(node);\n\n            ++_index;\n\n            if (more && !open) {\n                return 'continue';\n            }\n\n            if (more) {\n                // Push back parent node to the stack that will be able to continue\n                // the next iteration once all the child nodes of the current node\n                // have been completely explored.\n                stack.push([current, depth, _index]);\n\n                _index = 0;\n                depth = depth + 1;\n                current = node;\n            }\n        };\n\n        while (_index < current.children.length) {\n            var _ret = _loop();\n\n            if (_ret === 'continue') continue;\n        }\n    }\n\n    return flatten;\n};\n\nexports.flatten = flatten;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/flattree/lib/index.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../~/flattree/lib/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.defaultRowRenderer = undefined;\n\nvar _utils = __webpack_require__(6);\n\nvar defaultRowRenderer = function defaultRowRenderer(node) {\n    var id = node.id;\n    var label = node.label;\n    var state = node.state;\n    var depth = state.depth;\n    var more = state.more;\n    var open = state.open;\n    var path = state.path;\n    var children = state.children;\n    var total = state.total;\n    var _state$selected = state.selected;\n    var selected = _state$selected === undefined ? false : _state$selected;\n\n\n    var togglerContent = '';\n    if (more && open) {\n        togglerContent = '';\n    }\n    if (more && !open) {\n        togglerContent = '';\n    }\n    var toggler = (0, _utils.buildHTML)('a', togglerContent, {\n        'class': function () {\n            if (more && open) {\n                return (0, _utils.classNames)('tree-toggler');\n            }\n            if (more && !open) {\n                return (0, _utils.classNames)('tree-toggler', 'tree-closed');\n            }\n            return '';\n        }()\n    });\n    var title = (0, _utils.buildHTML)('span', (0, _utils.quoteattr)(label), {\n        'class': (0, _utils.classNames)('tree-title')\n    });\n    var treeNode = (0, _utils.buildHTML)('div', toggler + title, {\n        'class': 'tree-node',\n        'style': 'margin-left: ' + depth * 12 + 'px'\n    });\n    var treeItem = (0, _utils.buildHTML)('div', treeNode, {\n        'aria-id': id,\n        'aria-expanded': more && open,\n        'aria-depth': depth,\n        'aria-path': path,\n        'aria-selected': selected,\n        'aria-children': children ? Object.keys(children).length : 0,\n        'aria-total': total,\n        'class': (0, _utils.classNames)('tree-item', { 'tree-selected': selected })\n    });\n\n    return treeItem;\n};\n\nexports.defaultRowRenderer = defaultRowRenderer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/renderer.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/renderer.js?")},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n/**\n * Example #1:\n * =========================================================================\n * <a id=\"mymail href=\"http://mymail.example.com\">My Mail</a>\n *\n * buildHTML('a', 'My Mail', {\n *     id: 'mymail',\n *     href: 'http://mymail.example.com'\n * });\n *\n * Example #2:\n * =========================================================================\n * <input id=\"myinput\" type=\"text\" value=\"myvalue\" />\n *\n * buildHTML('input', {\n *   id: 'myinput',\n *   type: 'text',\n *   value: 'myvalue'\n * });\n *\n */\nvar buildHTML = function buildHTML(tag, html, attrs) {\n    switch (tag) {\n        case 'select':\n            if ((typeof html === 'undefined' ? 'undefined' : _typeof(html)) === 'object') {\n                var options = html || {};\n                html = '';\n                for (var value in options) {\n                    if (!options.hasOwnProperty(value)) {\n                        continue;\n                    }\n                    html += buildHTML('option', options[value] || '', { value: value });\n                }\n            }\n            break;\n\n        default:\n            if ((typeof html === 'undefined' ? 'undefined' : _typeof(html)) === 'object') {\n                attrs = html;\n                html = undefined;\n            }\n            break;\n    }\n\n    var h = '<' + tag;\n    for (var attr in attrs) {\n        if (!attrs.hasOwnProperty(attr)) {\n            continue;\n        }\n        if (typeof attrs[attr] !== 'undefined') {\n            h += ' ' + attr + '=\"' + quoteattr(attrs[attr]) + '\"';\n        }\n    }\n    h += typeof html !== 'undefined' ? '>' + html + '</' + tag + '>' : '/>';\n\n    return h;\n};\n\nvar classNames = function classNames() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    var classNames = [];\n    args.forEach(function (arg) {\n        if (Array.isArray(arg)) {\n            classNames = classNames.concat(arg);\n        } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {\n            Object.keys(arg).forEach(function (className) {\n                var ok = arg[className];\n                if (!!ok) {\n                    classNames.push(className);\n                }\n            });\n        } else {\n            classNames.push(arg);\n        }\n    });\n    return classNames.join(' ');\n};\n\n/**\n * The quoteattr() function is used in a context, where the result will not be evaluated by javascript but must be interpreted by an XML or HTML parser, and it must absolutely avoid breaking the syntax of an element attribute.\n */\nvar quoteattr = function quoteattr(s, preserveCR) {\n    preserveCR = preserveCR ? '&#13;' : '\\n';\n    return ('' + s). /* Forces the conversion to string. */\n    replace(/&/g, '&amp;') /* This MUST be the 1st replacement. */\n    .replace(/'/g, '&apos;') /* The 4 other predefined entities, required. */\n    .replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')\n    /*\n     * You may add other replacements here for HTML only\n     * (but it's not necessary).\n     * Or for XML, only if the named entities are defined in its DTD.\n     */\n    .replace(/\\r\\n/g, preserveCR) /* Must be before the next replacement. */\n    .replace(/[\\r\\n]/g, preserveCR);\n};\n\nexports.buildHTML = buildHTML;\nexports.classNames = classNames;\nexports.quoteattr = quoteattr;\n\n/*****************\n ** WEBPACK FOOTER\n ** ../src/utils.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///../src/utils.js?")}]);